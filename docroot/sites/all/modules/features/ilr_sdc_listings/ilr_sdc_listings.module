<?php
/**
 * @file
 * Code for the ilr_sdc_listings feature.
 */
define('ILR_SDC_MAX_DAYS_PAST', 90);
define('ILR_SDC_ONDEMAND_TEXT', 'This is an on demand class.');
define('ILR_SDC_PATH_ALIAS', 'programs/professional-programs/workshops-courses-training');
define('ILR_SDC_NO_RESULTS', 'No courses were found that match your search. Please try again.');
include_once 'ilr_sdc_listings.features.inc';

/**
 * Implements hook_form_alter().
 * Removes protected fields from sdc-related node forms
 */
function ilr_sdc_listings_form_alter(&$form, &$form_state, $form_id) {
  global $user;
  $node_forms_to_alter = array(
    'sdc_class_node_form',
    'sdc_course_node_form',
    'sdc_faculty_node_form',
  );
  if (in_array($form_id, $node_forms_to_alter)) {
    $protected_fields = _ilr_sdc_listings_get_protected_fields();
    foreach ($protected_fields[$form_id] as $key => $field_name) {
      if (isset($form[$field_name])) {
        $form[$field_name]['#disabled'] = 1;
      }
    }
  }
}

/**
 * Get importer files.
 * @return array
 *  Key are importer ids. Values are names of import files.
 */
function _ilr_sdc_listings_get_importer_files() {
  $importer_files = array(
    'sdc_course_importer' => 'ncourse',
    'sdc_class_importer' => 'nclass',
    'sdc_faculty_importer' => 'facultyFromSDC',
  );
  return $importer_files;
}

/**
 * Implements hook_block_info().
 */
function ilr_sdc_listings_block_info() {
  $blocks['course_search'] = array(
    'info' => t('Course search'),
    'cache' => DRUPAL_NO_CACHE
  );

  return $blocks;
}

/**
 * Implements hook_menu().
 *
 * Provide callback for redirecting from catalog number to node.
 */
function ilr_sdc_listings_menu() {
  $items = array();

  $items['catalog-course/%'] = array(
    'type' => MENU_CALLBACK,
    'access arguments' => array('access content'),
    'page callback' => '_ilr_sdc_listings_catalog_redirect',
    'page arguments' => array(1),
  );

  $items['course-interest/%'] = array(
    'type' => MENU_CALLBACK,
    'access arguments' => array('access content'),
    'page callback' => '_ilr_sdc_listings_request_info',
    'page arguments' => array(1),
  );

  $items['course-follow/%'] = array(
    'type' => MENU_CALLBACK,
    'access arguments' => array('access content'),
    'page callback' => '_ilr_sdc_listings_follow_course',
    'page arguments' => array(1),
  );

  $items['course-unsubscribe/%'] = array(
    'type' => MENU_CALLBACK,
    'access arguments' => array('access content'),
    'page callback' => '_ilr_sdc_listings_unfollow_course',
    'page arguments' => array(1),
  );

  $items['programs/professional-programs/courses/autocomplete'] = array(
    'page callback' => '_ilr_sdc_listings_autocomplete',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK
  );

  $items['programs/professional-programs/search'] = array(
    'type' => MENU_CALLBACK,
    'access arguments' => array('access content'),
    'page callback' => '_ilr_sdc_listings_custom_search',
  );

  return $items;
}

/**
 * Implements hook_block_view().
 */
function ilr_sdc_listings_block_view($delta = '') {
  $block = array();
  switch ($delta) {
    case 'course_search':
      $search_form = drupal_get_form('ilr_sdc_listings_search_form');
      $block['subject'] = '';
      $block['content'] = drupal_render($search_form);
      break;
  }
  return $block;
}

/**
 * Redirect to the node page the matches the catalog number.
 * @param $catalog_num
 * @return int
 */
function _ilr_sdc_listings_catalog_redirect($catalog_prefix) {
  $course = _ilr_sdc_listings_get_course_by_catalog_prefix($catalog_prefix);
  if ($course) {
    $nid = $course->nid;
    drupal_goto("node/$nid");
    return;
  }
  return MENU_NOT_FOUND;
}

function _ilr_sdc_listings_get_nid_from_catalog_prefix($catalog_prefix) {
  if ($course = _ilr_sdc_listings_get_node_from_catalog_prefix($catalog_prefix)) {
    return $course->nid;
  }
  return FALSE;
}

function _ilr_sdc_listings_get_course_by_catalog_prefix($catalog_prefix) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'sdc_course')
    ->fieldCondition('field_catalog_prefix', 'value', $catalog_prefix);
  $results = $query->execute();
  if (!empty($results['node'])) {
    return array_pop($results['node']);
  }
  return FALSE;
}

function _ilr_sdc_listings_get_class_by_id($class_id) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'sdc_class')
    ->fieldCondition('field_class_id', 'value', $class_id);
  $results = $query->execute();
  if (!empty($results['node'])) {
    return array_pop($results['node']);
  }
  return FALSE;
}

function _ilr_sdc_listings_get_faculty_by_sf_ids($sf_ids = NULL) {
  if (!$sf_ids) {
    return FALSE;
  }
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'sdc_faculty')
    ->fieldCondition('field_sf_record_id', 'value', $sf_ids, 'IN');
  $results = $query->execute();
  if (!empty($results['node'])) {
    return array_keys($results['node']);
  }
  return FALSE;
}

function _ilr_sdc_listings_get_course_by_sf_id($sf_id) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'sdc_course')
    ->fieldCondition('field_sf_record_id', 'value', $sf_id);
  $results = $query->execute();
  if (!empty($results['node'])) {
    return array_keys($results['node']);
  }
  return FALSE;
}

function _ilr_sdc_listings_get_program_by_sf_id($sf_id) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'taxonomy_term')
    ->entityCondition('bundle', 'course_program')
    ->fieldCondition('field_sf_record_id', 'value', $sf_id);
  $results = $query->execute();
  if (!empty($results)) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Sends the course request form to the page
 * @see ilr_sdc_listings.js
 */
function _ilr_sdc_listings_request_info($course_nid) {
  $block = entityform_block_block_view('course_request');
  unset($block['content']['field_course']);
  $content = drupal_render($block['content']);
  return $content;
}

/**
 * Sends the course request form to the page
 * @see ilr_sdc_listings.js
 */
function _ilr_sdc_listings_follow_course($course_nid) {
  $block = entityform_block_block_view('course_follow');
  unset($block['content']['field_course']);
  $content = drupal_render($block['content']);
  return $content;
}

/**
 *
 */
function _ilr_sdc_listings_unfollow_course($course_nid) {
  $content = $view = '';
  $params = drupal_get_query_parameters();
  if ($node = node_load($course_nid)) {
    if ($node->type != 'sdc_course') {
      drupal_set_message('Sorry, but there was an error processiong your request.','error');
      return '';
    }
    $view = node_view($node);
    if (isset($params['email'])) {
      if ($entityform_id = _ilr_sdc_listings_get_entityform_id($params['email'],$course_nid)) {
        _ilr_sdc_listings_remove_course_follower($entityform_id);
        drupal_set_message('You will no longer receive notifications regarding this course.');
      } // Email not found, show the unsubscribe form again
      else {
        $unsubscribe_form = drupal_get_form('ilr_sdc_listings_unsubscribe_form');
        $content = drupal_render($unsubscribe_form);
        drupal_set_message('Sorry, but we have no record of that email address.','warning');
      }
    } // Show the unsubscribe form
    else {
      $unsubscribe_form = drupal_get_form('ilr_sdc_listings_unsubscribe_form');
      $content = drupal_render($unsubscribe_form);
    }
  }
  $content .= drupal_render($view);
  return $content;
}

/**
 * Retrieves an entityform id based on an email and course nid
 * @see _ilr_sdc_listings_unfollow_course()
 */
function _ilr_sdc_listings_get_entityform_id($email, $course_nid) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'entityform')
    ->entityCondition('bundle', 'course_follow')
    ->propertyCondition('draft',0)
    ->fieldCondition('field_course', 'target_id', $course_nid)
    ->fieldCondition('field_email','email',$email);
  $result = $query->execute();

  if (isset($result['entityform'])) {
    $entityform_ids = array_keys($result['entityform']);
    return $entityform_ids;
  }
  return NULL;
}

/**
 * Checks for the existence of new classes
 * Triggers email notifications for each new class found
 */
function _ilr_sdc_listings_send_notifications() {
  $new_classes = _ilr_sdc_listings_get_new_class_nids();
  if (!empty($new_classes)) {
    foreach ($new_classes as $key => $nid) {
      _ilr_sdc_listings_send_notification_for_class($nid);
    }
  }
}

/**
 * Query for any class nodes added today
 * Confirm they are not cancelled
 * And that their dates are in the future
 */
function _ilr_sdc_listings_get_new_class_nids() {
  $timestamp = time();
  $today = date('Y-m-d');
  $last_notification = variable_get('ilr_sdc_listings_cron_last_execution', time());
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'sdc_class')
    ->propertyCondition('status', NODE_PUBLISHED)
    ->propertyCondition('created', $last_notification, '>')
    ->fieldCondition('field_class_dates', 'value', $today, '>')
    ->fieldCondition('field_cancelled', 'value', 1, '!=')
    ->fieldCondition('field_is_full', 'value', 1, '!=');
  $results = $query->execute();
  if (!empty($results['node'])) {
    $nids = array_keys($results['node']);
    return $nids;
  }
  return [];
}

/**
 * Implements drupal_mail for notifications
 * BCC's anyone who has registered to follow the given course
 */
function _ilr_sdc_listings_send_notification_for_class($class_nid) {
  $followers = _ilr_sdc_listings_get_course_followers($class_nid);
  if (!empty($followers)) {
    $class_wrapper = ilr_get_node_wrapper($class_nid);
    $bcc = _ilr_sdc_listings_get_email_bcc_addresses($followers);
    $body = _ilr_sdc_listings_get_course_notification_content($class_nid);

    if (ilr_is_production_site()) {
      $params = array(
        'bcc'     => $bcc,
        'subject' => "Now Available: " . $class_wrapper->label(),
        'content' => $body,
      );

      drupal_mail(
        'ilr_sdc_listings_new_class_notification',
        'course_notification',
        'ilrweb@cornell.edu',
        LANGUAGE_NONE,
        $params,
        _ilr_sdc_listings_get_admin_email_for_class($class_wrapper)
      );
    } // Not production so log it instead
    else {
      watchdog(
        'ilr_sdc_listings',
        'New class email prepared for %class: %body',
        array(
          '%class' => $class_wrapper->label(),
          '%body' => $body
        ),
        WATCHDOG_INFO
      );
    }
  }
}

/**
 * Creates the html content for the email
 * @todo Implement a more robust version that works with gmail
 */
function _ilr_sdc_listings_get_course_notification_content($class_nid) {
  $class_wrapper = ilr_get_node_wrapper($class_nid);
  $course_nid = $class_wrapper->field_course[0]->getIdentifier();
  $course = node_load($course_nid);
  $wrapper = (!empty($class_wrapper->body->value())) //Check for class description
    ? $class_wrapper
    : ilr_get_node_wrapper($course); //Default to course description
  $summary = (!empty($wrapper->body->summary->value()))
    ? $wrapper->body->summary->value()
    : text_summary($wrapper->body->value->value());
  $link = url('node/'.$course_nid, array('absolute' => true));
  $title = _ilr_sdc_listings_get_prefixed_node_title($course,'sdc_course');
  $message = '<style type="text/css">a {color:#b31b1b} span {display:block}</style>';
  $message .= '<p>A new date has been scheduled for the following Cornell ILR Public Offering:</p>';
  $message .= '<h2><a href="'.$link.'">'.$title.'</a></h2>';
  $message .= $summary;
  $message .= '<p>'._ilr_sdc_listings_get_class_detail_markup_for_email(node_load($class_nid)).'</p>';
  $message .= '<p>For questions or more information, please contact ILR Customer Service at 866-470-1922 or emailing us at <a href="mailto:ilrcustomerservice@cornell.edu">ilrcustomerservice@cornell.edu</a>.</p>';
  $unsubscribe_link = _ilr_sdc_listings_get_unsubscribe_link($course_nid);
  $message .= '<p>If you no longer want to receive notifications regarding this course, you can <a href="'.$unsubscribe_link.'">unsubscribe here</a>.</p>';
  $message .= '<p>Regards,</p>';
  $message .= '<p>ILR Customer Service</p>';
  return $message;
}

function _ilr_sdc_listings_get_class_detail_markup_for_email($class) {
  $class_wrapper = ilr_get_node_wrapper($class);
  $city = (!empty($class_wrapper->field_address->value()))
    ? $class_wrapper->field_address->locality->value()
    : '';
  $state = $class_wrapper->field_address->administrative_area->value();
  $markup = 'DATE: '._ilr_sdc_listings_get_class_datespan($class).'<br>';
  $markup .= 'TIME: '._ilr_sdc_listings_get_class_timespan($class).'<br>';
  $markup .= (_ilr_sdc_listings_is_online($class)) ? 'LOCATION: Online<br>' : "LOCATION: $city, $state<br>";
  $markup .= "PRICE: $".$class_wrapper->field_price->value();
  return $markup;
}

/**
 * Provides ability for courses to override admin email, according to:
 * 1. Course admin email field on course
 * 2. Email on sponsoring organization
 * 3. Generic Customer Service email
 * @see _forms_get_course_admin_email_addresses()
 */
function _ilr_sdc_listings_get_admin_email_for_class($class_wrapper) {
  $course_nid = $class_wrapper->field_course[0]->getIdentifier();
  $course_wrapper = ilr_get_node_wrapper($course_nid);
  $admin_emails = array();
  if ($email = $course_wrapper->field_email->value()) {
    $admin_emails[] = $email;
  } else {
    foreach ($course_wrapper->field_course_sponsor_reference->getIterator() as $delta => $term_wrapper) {
      if ($email = $term_wrapper->field_email->value()) {
        $admin_emails[] = $email;
      }
    }
  }

  $admin_email = (count($admin_emails))
    ? $admin_emails[0]
    : 'Cornell University ILR School <ilrcustomerservice@cornell.edu>';

  return $admin_email;
}

/**
 * Set the unsubscribe link
 * @see _ilr_sdc_listings_get_course_notification_content()
 */
function _ilr_sdc_listings_get_unsubscribe_link($course_nid) {
  return url("course-unsubscribe/$course_nid",array('absolute'=>TRUE));
}

/**
 * Implements hook_mail().
 */
function ilr_sdc_listings_new_class_notification_mail($key, &$message, $params) {
  $message['headers']['MIME-Version'] = '1.0';
  $message['headers']['Content-Type'] = 'text/plain;charset=utf-8';
  $message['headers']['Bcc'] = $params['bcc'];
  $message['subject'] = $params['subject'];
  $message['body'][] = $params['content'];
}

/**
 * Creates the Bcc string based on the entityforms that have been submitted
 */
function _ilr_sdc_listings_get_email_bcc_addresses($follower_forms) {
  $emails = [];
  if (!ilr_is_production_site()) { // Don't bcc anyone
    return '';
  }
  foreach ($follower_forms as $eid => $entityform) {
    $wrapper = entity_metadata_wrapper('entityform', $entityform);
    $emails[] = $wrapper->field_email->value();
  }
  $emails = array_unique($emails);
  return implode(',', $emails);
}

/**
 * Queries for the followers of the class's parent course
 * As well as certificates attached to the course.
 *
 * @return Array An array of entityforms that were submitted by the users
 */
function _ilr_sdc_listings_get_course_followers($class_nid) {
  $class_wrapper = ilr_get_node_wrapper($class_nid);
  $course_nid = $class_wrapper->field_course[0]->getIdentifier();
  $course_nids = _ilr_sdc_listings_get_certificate_programs_for_course($course_nid);
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'entityform')
    ->entityCondition('bundle', 'course_follow')
    ->propertyCondition('draft', 0)
    ->fieldCondition('field_course', 'target_id', $course_nids,'IN');
  $result = $query->execute();

  if (isset($result['entityform'])) {
    $entityform_ids = array_keys($result['entityform']);
    $followers = entity_load('entityform', $entityform_ids);
    return $followers;
  }
  return NULL;
}

/**
 * Queries for the certificate programs that have the current course
 * as a part of the curriculum
 */
function _ilr_sdc_listings_get_certificate_programs_for_course($course_nid) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'certificate_programs')
    ->fieldCondition('field_course', 'target_id', $course_nid);
  $result = $query->execute();

  if (isset($result['node'])) {
    $nids = array_keys($result['node']);
    array_push($nids, $course_nid);
    return $nids;
  }
  return array($course_nid);
}

/**
 * Loads the appropriate entityform and sets the draft status to '1'
 */
function _ilr_sdc_listings_remove_course_follower($entityform_id) {
  $entityform = current(entity_load('entityform', $entityform_id));
  $wrapper = entity_metadata_wrapper('entityform', $entityform);
  $wrapper->draft->set(1);
  $wrapper->save();
}

/**
 *  Create the unsubscribe form
 *  @see _ilr_sdc_listings_unfollow_course()
 */
function ilr_sdc_listings_unsubscribe_form($form, &$form_state) {
  $form['email'] = array(
    '#type' => 'textfield',
    '#attributes' => array(
      'placeholder' => 'your email',
    ),
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => 'unsubscribe',
    '#name' => '',
    '#attributes' => array(
      'id' => 'unsubscribe-form-submit',
      'class' => array('button'),
    ),
  );
  $form['#action'] = url(current_path(), array('absolute' => TRUE));
  $form['#method'] = 'get';
  $form['#pre_render'][] = 'ilr_sdc_listings_search_form_modify'; // Re-use functionality from search form

  return $form;
}

/**
 *  Create the search form
 */
function ilr_sdc_listings_search_form($form, &$form_state) {
  $form['search_input'] = array(
    '#type' => 'container',
    '#attributes' => array(
      'id' => array('search-input'),
    ),
  );
  $form['search_input']['s'] = array(
    '#title' => t(''),
    '#type' => 'textfield',
    //'#size' => 20,
    '#attributes' => array(
      'placeholder' => 'Search ILR offerings',
      'aria-label' => 'Search ILR offerings'
    ),
    '#default_value' => isset($_REQUEST['s']) ? $_REQUEST['s'] : '',
    '#autocomplete_path' => 'programs/professional-programs/courses/autocomplete',
  );

  $form['search_input']['submit'] = array(
    '#type' => 'submit',
    '#value' => 'Search',
    '#name' => '',
    '#attributes' => array('id' => 'search-form-submit'),
  );

  $form['#action'] = url('programs/professional-programs/search');
  $form['#method'] = 'get';
  $form['#pre_render'][] = 'ilr_sdc_listings_search_form_modify';

  return $form;
}

function ilr_sdc_listings_search_form_modify($form){
  unset($form['form_token']);
  unset($form['form_build_id']);
  unset($form['form_id']);
  return $form;
}

/**
 * Returns matches for the search form based on the topics,
 * course title and keywords, in that order
 */
function _ilr_sdc_listings_autocomplete($string='afdjakls') {
  $topic_matches = _ilr_sdc_listings_taxonomy_autocomplete('field_course_topic_reference', $string);
  $title_matches = _ilr_sdc_listings_get_autocomplete_titles($string);
  $keyword_matches = _ilr_sdc_listings_taxonomy_autocomplete('field_keywords', $string);

  $merged = array_merge(
    $topic_matches,
    $title_matches,
    $keyword_matches
  );
  $merged = (!empty($merged)) ? $merged : array(); // Fixes js error for empty results
  return drupal_json_output($merged);
}

function _ilr_sdc_listings_get_autocomplete_titles($string) {
  $results = db_query("SELECT n.title FROM {node} n WHERE n.title LIKE :title AND n.type = :type", array(":title"=> '%'. trim($string, " ,!?") . '%', ":type"=> 'sdc_course'))->fetchAll();
  if (!empty($results)) {
    foreach($results as $node) {
      $title_matches[$node->title] = check_plain($node->title);
    }
  }
  return $title_matches;
}


/**
 * @see taxonomy_autocomplete in taxonomy.pages.inc
 * Modified here to return the matches, rather than echoing the json
 * This allows us to merge the results with other queries
 */
function _ilr_sdc_listings_taxonomy_autocomplete($field_name = '', $tags_typed = '') {
  // If the request has a '/' in the search text, then the menu system will have
  // split it into multiple arguments, recover the intended $tags_typed.
  $args = func_get_args();
  // Shift off the $field_name argument.
  array_shift($args);
  $tags_typed = implode('/', $args);

  // Make sure the field exists and is a taxonomy field.
  if (!($field = field_info_field($field_name)) || $field['type'] !== 'taxonomy_term_reference') {
    // Error string. The JavaScript handler will realize this is not JSON and
    // will display it as debugging information.
    print t('Taxonomy field @field_name not found.', array('@field_name' => $field_name));
    exit;
  }

  // The user enters a comma-separated list of tags. We only autocomplete the last tag.
  $tags_typed = drupal_explode_tags($tags_typed);
  $tag_last = drupal_strtolower(array_pop($tags_typed));

  $term_matches = array();
  if ($tag_last != '') {

    // Part of the criteria for the query come from the field's own settings.
    $vids = array();
    $vocabularies = taxonomy_vocabulary_get_names();
    foreach ($field['settings']['allowed_values'] as $tree) {
      $vids[] = $vocabularies[$tree['vocabulary']]->vid;
    }

    $query = db_select('taxonomy_term_data', 't');
    $query->addTag('translatable');
    $query->addTag('term_access');

    // Do not select already entered terms.
    if (!empty($tags_typed)) {
      $query->condition('t.name', $tags_typed, 'NOT IN');
    }
    // Select rows that match by term name.
    $tags_return = $query
      ->fields('t', array('tid', 'name'))
      ->condition('t.vid', $vids)
      ->condition('t.name', '%' . db_like($tag_last) . '%', 'LIKE')
      ->range(0, 10)
      ->execute()
      ->fetchAllKeyed();

    $prefix = count($tags_typed) ? drupal_implode_tags($tags_typed) . ', ' : '';

    foreach ($tags_return as $tid => $name) {
      $n = $name;
      // Term names containing commas or quotes must be wrapped in quotes.
      if (strpos($name, ',') !== FALSE || strpos($name, '"') !== FALSE) {
        $n = '"' . str_replace('"', '""', $name) . '"';
      }
      $term_matches[$prefix . $n] = check_plain($name);
    }
  }

  return $term_matches;
}

/**
 * Loops through search term(s)
 * Creates De-duped EFQ's and returns resulting content
 */
function _ilr_sdc_listings_custom_search(){
  $params = drupal_get_query_parameters();
  $results = $nids = array();
  $content = '';
  if (isset($params['s'])) {
    $search = $params['s'];
    if (!empty($search)) {
      $content = '<div class="search-result-details"><h2>You searched for <span class="search-term">'. $search .'</span>.</h2>';
      // Check node titles for search string first
      $title_matches = _ilr_sdc_listings_query_title_for_string($search);
      // Check for exact matches
      $search_string_matches = _ilr_sdc_listings_get_course_query_courses_for_strings(array($search));
      // Get rid of common words before querying
      $ignore_words = explode(',',PATHAUTO_IGNORE_WORDS);
      foreach ($ignore_words as &$word) {
        $word = '/\b' . preg_quote($word, '/') . '\b/';
      }
      $search = preg_replace($ignore_words, '', $search);
      $words = str_getcsv($search, ' ');
      $partial_matches = (count($words) > 1) // Only query again if the search string has more than 1 word
        ? _ilr_sdc_listings_get_course_query_courses_for_strings($words)
        : array();
      $results = array_unique(array_merge_recursive($title_matches, $search_string_matches, $partial_matches));
      $content .= _ilr_sdc_listings_render_search_results($results);
    }
    else {
      $content = '<p>Your search was blank. Please be sure to include a search term.</p>';
    }
  }
  return $content;
}

function _ilr_sdc_listings_get_course_query_courses_for_strings($string_array) {
  $results = $nids = array();
  foreach ($string_array as $key => $word) {
    // Key/value pairs are for term references
    $fields = array(
      'field_catalog_prefix',
      'course_topic' => 'field_course_topic_reference',
      'course_keywords' => 'field_keywords',
      'body',
    );

    foreach ($fields as $key => $field_name) {
      if (is_numeric($key)) {
        $nids = _ilr_sdc_listings_query_field_for_string($field_name, $word);
      }
      else {
        if ($existing_term = taxonomy_get_term_by_name($word, $key)) {
          $key = key($existing_term);
          $term = $existing_term[$key];
          $nids = _ilr_sdc_listings_query_field_for_string($field_name, '', $term->tid);
        }
      }
      $results = array_merge($results,$nids);
    }
  }
  return $results;
}

function _ilr_sdc_listings_query_title_for_string($string) {
  $query = new EntityFieldQueryDeduped();
  $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', array('sdc_course','sdc_class'),'IN')
    ->propertyCondition('status', NODE_PUBLISHED)
    ->propertyCondition('title', '([[:<:]]|^)'. trim($string, " ,!?") . '([[:>:]]|$)', 'REGEXP');
  $result = $query->execute();
  if (isset($result['node'])) {
    foreach ($result['node'] as $nid => $node_info) {
      if ($node_info->type == 'sdc_class') {
        _ilr_sdc_listings_handle_class_series_results($result, $nid);
      }
    }
    return array_keys($result['node']);
  }
  return array();
}

function _ilr_sdc_listings_query_field_for_string($field, $string, $tid=NULL) {
  $query = new EntityFieldQueryDeduped();
  $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', array('sdc_course','sdc_class'),'IN')
    ->propertyCondition('status', NODE_PUBLISHED);
  if ($tid) { // It's a term reference
    $query->fieldCondition($field, 'tid', $tid);
  } // It's a field with a value
  else {
    $query->fieldCondition($field, 'value', '([[:<:]]|^)'. trim($string, " ,!?") . '([[:>:]]|$)', 'REGEXP');
  }
  $result = $query->execute();
  if (isset($result['node'])) {
    foreach ($result['node'] as $nid => $node_info) {
      if ($node_info->type == 'sdc_class') {
        _ilr_sdc_listings_handle_class_series_results($result, $nid);
      }
    }
    return array_keys($result['node']);
  }
  return array();
}

/**
 * The javascript is written to handle courses with classes, but not classes themselves
 * Since we need the search to query classes, when results are found, we check to see
 * if they are part of a series, and add the course if so
 * Otherwise, we simply unset the result
 */
function _ilr_sdc_listings_handle_class_series_results(&$result, $nid) {
  $class = node_load($nid);
  if (_ilr_sdc_listings_is_series($class)) {
    $wrapper = ilr_get_node_wrapper($class);
    $course_nid = $wrapper->field_course[0]->value()->nid;
    $result['node'][$course_nid] = (object) array(
      'nid' => $wrapper->field_course[0]->value()->nid,
      'vid' => $wrapper->field_course[0]->value()->vid,
      'type' => 'sdc_course',
    );
  }
  // Now remove the class from the results, since classes are handled by their courses
  unset($result['node'][$nid]);
}

function _ilr_sdc_listings_render_search_results($results) {
  if (count($results)) {
    $result_count = format_plural(count($results), '1 result', '@count results');
    $content = $result_count .' found.</p>';
    $content .= _ilr_sdc_listings_add_sort_elements(array('relevance','date','title','program'));
    $content .= '</div>';// closes .search-result-details
    $content .= '<div class="view-sdc-course-listing">'; // The JS needs this, see fixSeriesClasses
    $nids = array_values($results);
    $nodes = node_load_multiple($nids);
    foreach ($nodes as $nid => $node) {
      $node_view = node_view($node,'teaser');
      $content .= drupal_render($node_view);
    }
    $content .= '</div>';
  }
  else {
    $content = '<p>'.ILR_SDC_NO_RESULTS.'</p></div>';// closes .search-result-details
  }
  return $content;
}

function _ilr_sdc_listings_add_sort_elements($sort_types) {
  $content = '<div class="sort">';
  $content .= '  <p>Sort by : ';
  foreach ($sort_types as $key => $value) {
    $class = ($key == 0) ? 'current-sort' : '';
    $content .= '<a href="#" data-sort="'.$value.'" class="'.$class.'">'.$value.'</a> ';
  }
  $content .= '</p></div>';
  return $content;
}
/**
 * Implements hook_page_alter().
 * Places the course search at the content top if on the page
 */
function ilr_sdc_listings_page_alter(&$page) {
  if (isset($page['content']['ilr_sdc_listings_course_search'])) {
    $page['content']['ilr_sdc_listings_course_search']['#weight'] = $page['content']['system_main']['#weight'] - 10;
  }
}
/**
 * Implements hook_node_view().
 */
function ilr_sdc_listings_node_view($node, $view_mode, $langcode) {
  switch ($node->type) {
    case 'sdc_course':
      $alias = drupal_get_path_alias('node/'.$node->nid);
      _ilr_sdc_listings_add_canonical_metatag($node, $view_mode);
      _ilr_sdc_listings_add_prefix_to_title($node, $node->type, $view_mode);
      _ilr_sdc_listings_course_add_instructors($node, $view_mode);
      _ilr_sdc_listings_course_add_classes($node, $view_mode);
      if ($view_mode == 'reference_field') {
        _ilr_sdc_listings_update_reference($node);
      }
      elseif ($view_mode == 'teaser') { // We need to reposition the title in order to style the columns
        $original_markup = isset($node->content['body'])
          ? $node->content['body'][0]['#markup']
          : '';
        $node->content['body'][0]['#markup'] = '<h2><a href="/'.$alias.'">'.$node->title.'</a></h2>' . $original_markup;
        $node->title = '';
      }
      elseif ($view_mode == 'alternate_teaser') {
        $original_class_detail_markup = isset($node->content['classes'])
          ? $node->content['classes']['#markup']
          : '';
        $node->content['classes']['#markup'] = $original_class_detail_markup
          . '<h2><a href="/'.$alias.'">'.$node->title.'</a></h2>';
        $node->title = '';
        $course_info_link = '<a class="course-details" href="/'.$alias.'">Learn More</a>';

        if (isset($node->content['body'])) {
          $markup = $node->content['body'][0]['#markup'].$course_info_link;
          $node->content['body'][0] = array('#markup' => $markup);
        }
      }
      break;
    case 'sdc_class':
      _ilr_sdc_listings_set_default_body($node);
      _ilr_sdc_listings_add_prefix_to_title($node, $node->type, $view_mode);
      _ilr_sdc_listings_class_full_msg($node, $view_mode);
      _ilr_sdc_listings_class_add_reg_form($node, $view_mode);
      _ilr_sdc_listings_class_add_readmore($node, $view_mode);
      _ilr_sdc_listings_class_format_online($node, $view_mode);
      if ($view_mode == 'full') {
        _ilr_sdc_listings_add_noindex_content();
      }
      break;
  }
}

/**
 * Implements hook_html_head_alter().
 * Node.module adds a canonical url to the relative path
 * We set it here to the full path, and check for potential dupes added for wrapped nodes
 * @see _ilr_sdc_listings_add_canonical_metatag().
 */
function ilr_sdc_listings_html_head_alter(&$head_elements) {
  $potential_dupes = array();
  foreach ($head_elements as $key => $element) {
    if (isset($element['#attributes']['rel']) && $element['#attributes']['rel'] == 'canonical') {
      if ($node = menu_get_object()) {
        $full_path = url('node/'.$node->nid, array('absolute' => TRUE));
        // Set the href to the full_path
        $head_elements[$key]['#attributes']['href'] = $full_path;
        // Check for duplicates
        if (in_array($full_path, $potential_dupes)) {
          unset($head_elements[$key]); // Duplicate found, so remove it
        } // Dupe not found, so add it to the $potential_dupes
        else {
          $potential_dupes[] = $full_path;
        }
      }
    }
  }
}

/**
 * Add special link to class detail
 * @param $node
 * @param $read_more_link
 */
function _ilr_sdc_listings_class_add_readmore(&$node, $view_mode) {
  if ($view_mode == 'reference_field') {
    $node_title_stripped = strip_tags($node->title);
    $links['node-readmore'] = array(
      'title' => t('Learn more about this class and its faculty'),
      'href' => 'node/' . $node->nid,
      'html' => TRUE,
      'attributes' => array('rel' => 'tag', 'title' => $node_title_stripped),
    );
    $node->content['links']['node'] = array(
      '#theme' => 'links__node__node',
      '#links' => $links,
      '#attributes' => array('class' => array('links', 'inline')),
    );
  }
}

function _ilr_sdc_listings_add_sponsor_data_to_course(&$variables) {
  $wrapper = ilr_get_node_wrapper($variables['node']);
  $sponsor = $wrapper->field_course_sponsor_reference->value();
  if (!empty($sponsor)) {
    $variables['attributes_array']['data-sponsor'] = $sponsor[0]->name;
  } else {
    unset($variables['content']);
  }
}

/**
 * Implements hook_node_view_alter().
 */
function ilr_sdc_listings_node_view_alter(&$build) {
  if ($build['#bundle'] == 'sdc_class') {
    _ilr_sdc_listings_class_view_alter($build);
  }
}

/**
 * Alters Class node view.
 *
 * Remove most elements from address.
 *
 * Add course link.
 * @param $build
 */
function _ilr_sdc_listings_class_view_alter(&$build) {
  if ($build['#view_mode'] == 'teaser') {
    if (isset($build['field_address'][0]['#address'])) {
      $address_elements = array('locality', 'administrative_area');
      foreach (element_children($build['field_address'][0]['#address']) as $element) {
        if (!in_array($element, $address_elements)) {
          $build['field_address'][0]['#address'][$element] = NULL;
        }
      }
    }
    unset($build['links']);
    $build['field_course'][0] = _ilr_sdc_listings_class_course_link($build['#node']);
  }
}

/**
 * Update class link to point to class node detail
 * @param $class_node
 * @return array
 *  Render array for link.
 */
function _ilr_sdc_listings_class_course_link($class_node) {
  $node_wrapper = ilr_get_node_wrapper($class_node);
  $course_title = $node_wrapper->title->value();
  return array(
    '#theme' => 'link',
    '#text' => $course_title,
    '#path' => 'node/' . $class_node->nid,
    '#options' => array(
      'html' => FALSE,
      'attributes' => array(),
    ),
  );
}

/**
 * Remove address if class is online.
 * @param $node
 * @param $view_mode
 */
function _ilr_sdc_listings_class_format_online($node, $view_mode) {
  $node_wrapper = ilr_get_node_wrapper($node);
  if ($node_wrapper->field_online_class->value()) {
    if (isset($node->content['field_address'])) {
      unset($node->content['field_address']);
    }
  }
}

function _ilr_sdc_listings_add_noindex_content() {
  $tag = array(
    '#type' => 'html_tag',
    '#tag' => 'meta',
    '#attributes' => array(
      'name' => 'robots',
      'content' => 'noindex',
    ),
  );
  drupal_add_html_head($tag, 'robots');
}

/**
 * Checks the on_demand field value, as well as the catalog_prefix
 * As of 2015, all on-demand classes start with OD prefix, though sometimes
 * on-demand classes have come through the feed without being flagged as such
 */
function _ilr_sdc_listings_is_ondemand($node) {
  if ($node->type == 'sdc_class') {
    $node_wrapper = ilr_get_node_wrapper($node);
    return $node_wrapper->field_on_demand->value() || substr($node_wrapper->field_course[0]->field_catalog_prefix->value(), 0, 2) == 'OD';
  }
  return FALSE;
}

/**
 * Checks the city for the hack used in SDC for "On-Line"
 */
function _ilr_sdc_listings_is_online($node) {
  $node_wrapper = ilr_get_node_wrapper($node);
  if ($node->type == 'sdc_class') {
    $course_wrapper = ilr_get_node_wrapper($node_wrapper->field_course[0]->value()->nid);
    return $node_wrapper->field_setting->value() == 'online';
  }
  elseif ($node->type == 'sdc_course') {
    return $node_wrapper->field_setting->value() == 'online';
  }
  return FALSE;
}

/**
 * Checks the course or class for the appropriate course's series flag
 */
function _ilr_sdc_listings_is_series($course_or_class) {
  if ($course_or_class->type == 'sdc_course') {
    $course = $course_or_class;
  }
  else {
    $class_wrapper = ilr_get_node_wrapper($course_or_class);
    $course = ($class_wrapper->field_course)
      ? $class_wrapper->field_course[0]->value()
      : NULL;
  }
  if ($course) {
    $course_wrapper = ilr_get_node_wrapper($course);
    if (!empty($course_wrapper->field_course_series)) {
      return $course_wrapper->field_course_series->value();
    }
  }

  return FALSE;
}

/**
 * Add Class registration form to full course node view.
 */
function _ilr_sdc_listings_class_add_reg_form($class_node, $view_mode) {
  if ($view_mode == 'full') {
    $class_node_wrapper = ilr_get_node_wrapper($class_node);
    $course = $class_node_wrapper->field_course[0]->value();
    $class_available = _ilr_sdc_listings_get_classes_for_course($course, array($class_node->nid));
    if ($class_available) {
      $nids = _ilr_sdc_listings_get_classes_for_course($course);
      $classes = node_load_multiple($nids);
      $available_classes = array_keys(_ilr_sdc_listings_remove_overflow_sessions($classes));
      $form = drupal_get_form('ilr_sdc_listings_class_reg_form', array($class_node), TRUE, FALSE);
      $class_node->content['classes'] = $form;
      $class_node->content['request_info'] = array('#markup' => _ilr_sdc_listings_generate_request_info_markup($course, $view_mode));
      $class_node->content['#group_children']['classes'] = 'group_sidebar';
      $class_node->content['#group_children']['request_info'] = 'group_sidebar';
      // Add a link to other classes if more than 1
      if (count($available_classes) > 1) {
        $link_text = (_ilr_sdc_listings_is_series($course))
          ? 'See all offerings in ' . $course->title
          : 'Show all dates';
        $alias = drupal_get_path_alias('node/'.$course->nid);
        $class_node->content['other_classes_link'] = array(
          '#markup' => '<p><a href="/'.$alias.'">'.$link_text.'</a></p>',
        );
        $class_node->content['#group_children']['other_classes_link'] = 'group_sidebar';
      }
    } // Class in the past
    else {
      $class_details = '<div class="class-details">';
      $class_details .= _ilr_sdc_listings_get_class_detail_markup($class_node);
      $class_details .= '</div>';
      $course_url = drupal_get_path_alias('node/' . $course->nid);
      $class_details .= '<div class="course-return"><p><a href="/'. $course_url .'">See current dates</a></p></div>';
      $class_node->content['classes']['#markup'] = $class_details;
      $class_node->content['#group_children']['classes'] = 'group_sidebar';
    }
  }
}

/**
 * Adds class full message to node class view.
 * @param $course_node
 * @param $view_mode
 */
function _ilr_sdc_listings_class_full_msg($class_node, $view_mode) {
  $node_wrapper = ilr_get_node_wrapper($class_node);
  if ($node_wrapper->field_is_full->value()) {
    switch ($view_mode) {
      case 'teaser':
        $full_msg = '[' . variable_get('sdc_class_full_teaser') . ']';
        $weight = 100;
        break;
      default:
        $full_msg = '[' . variable_get('sdc_class_full_full') .']';
        $weight = -100;
        break;
    }
    $class_node->content['body'][0]['#markup'] .= "<p>$full_msg</p>";
  }
  return array();
}

/**
 * Add class listing form to node course view.
 * @param $course_node
 * @param $view_mode
 */
function _ilr_sdc_listings_course_add_classes(&$course_node, $view_mode) {
  if ($view_mode == 'teaser' || $view_mode == 'full' || $view_mode == 'alternate_teaser') {
    $wrapper = ilr_get_node_wrapper($course_node);
    $next_available = (in_array($view_mode, ['teaser','alternate_teaser'])) ? TRUE : FALSE;
    $class_nids = _ilr_sdc_listings_get_classes_for_course($course_node,NULL,$next_available);
    if ($class_nids) {
      $classes = node_load_multiple($class_nids);
      $class_nodes = _ilr_sdc_listings_remove_overflow_sessions($classes);
      $class_node = reset($class_nodes);
      $class_wrapper = ilr_get_node_wrapper($class_node);
      $content = '';
      $price = _ilr_sdc_listings_get_price($class_node, $course_node);
      if (_ilr_sdc_listings_is_ondemand($class_node) || _ilr_sdc_listings_is_online($class_node)) {
        $format = _ilr_sdc_listings_generate_course_format_label($class_wrapper->field_course[0]->value()->nid);
        $content .= '<div class="class-details"><span class="timespan">ONLINE</span>';
        $content .= '<p class="cost">$'. $price .'</p>';
        if (_ilr_sdc_listings_is_ondemand($class_node)) {
          // This is on the course node for on demand
          $content .= '<span class="message">Take this self-paced '. strtolower($format) .' at your convenience</span>';
        }
        $content .= '</div>';
      }
      else {
        $content = '<p class="cost">$'. $price .'</p>';
      }

      if ($view_mode == 'full') {
        $form = drupal_get_form('ilr_sdc_listings_class_reg_form', $class_nodes);
        $content .= drupal_render($form);
        $content .= _ilr_sdc_listings_generate_request_info_markup($course_node, $view_mode);
      } // teaser list view
      else {
        $content = _ilr_sdc_listings_generate_class_link_markup($class_nodes, $view_mode);
      }
      if (_ilr_sdc_listings_is_series($course_node)) {
        _ilr_sdc_listings_add_class_teasers_for_series($course_node, $class_nodes, $view_mode);
      } // Not a series
      else {
        $course_node->content['classes'] = array('#markup' => $content);
        $course_node->content['#group_children']['classes'] = 'group_sidebar';
      }
    } // No classes available
    else {
      if ($view_mode == 'alternate_teaser') {
        $markup = _ilr_sdc_listings_generate_unscheduled_course_markup($course_node, $view_mode);
        $course_node->content['classes'] = array('#markup' => $markup);
        $course_node->content['#group_children']['classes'] = 'group_sidebar';
      }
      else {
        $markup = _ilr_sdc_listings_generate_request_info_markup($course_node, $view_mode);
        $course_node->content['classes'] = array(
          '#type' => 'markup',
          '#markup' => $markup,
        );
      }
    }
    $course_node->content['classes']['#weight'] = 2;
  }
}

/**
 * Add the class instructors to the course nodes.
 * @param $course_node
 * @param $view_mode
 */
function _ilr_sdc_listings_course_add_instructors(&$course_node, $view_mode) {
  if ($view_mode == 'full') {
    $class_nids = _ilr_sdc_listings_get_classes_for_course($course_node);
    if ($class_nids) {
      $content = '<div class="class-details">';
      $classes = node_load_multiple($class_nids);
      foreach ($classes as $class) {
        $class_node_wrapper = ilr_get_node_wrapper($class);
        $class_id = _ilr_sdc_listings_get_class_id($class_node_wrapper);
        if ($class_node_wrapper->field_cancelled->value() != 1 && $class_node_wrapper->field_is_full->value() != 1) {
          $content .= _ilr_sdc_listings_generate_faculty_markup($class, $class_id, count($classes));
        }
      }
      $content .= '</div>';
      $course_node->content['instructors'] = array('#markup' => $content,'#weight' => 20);
      $group_main_content = field_group_load_field_group('group_main_content', 'node', 'sdc_course', 'default');
      $course_node->content['#groups']['group_main_content'] = $course_node->content['#fieldgroups']['group_main_content'] = $group_main_content;
      $course_node->content['#group_children']['instructors'] = 'group_main_content';
    }
  }
}

function _ilr_sdc_listings_add_class_teasers_for_series(&$course_node, $class_nodes, $view_mode) {
  if ($view_mode == 'teaser') { // It's a listing page, so replace course with class info
    _ilr_sdc_listings_replace_series_course_info_with_class_info($course_node,$class_nodes);
  }
  // Show the class info for each in the series. Note the first element was already removed
  // if we're looking at a listing
  foreach ($class_nodes as $key => $class) {
    _ilr_sdc_listings_set_default_body($class);
    $class_teaser = node_view($class,'teaser');
    // Hide the field data we don't want
    unset($class_teaser['field_class_dates']);
    unset($class_teaser['field_address']);

    // Create and position the sidebar content
    $group_sidebar = field_group_load_field_group('group_sidebar', 'node', 'sdc_class', 'default');
    $class_teaser['classes'] = array(
      '#markup' => _ilr_sdc_listings_generate_class_link_markup(array($class)),
    );
    $class_teaser['#groups']['group_sidebar'] = $class_teaser['#fieldgroups']['group_sidebar'] = $group_sidebar;
    $class_teaser['#group_children']['classes'] = 'group_sidebar';
    // Add the markup to the course body
    $course_node->content['body'][0]['#markup'] .= render($class_teaser);
  }
}

/**
 * If there are scheduled classes for a series, we remove the course info and
 * replace it with the next class info for that series
 */
function _ilr_sdc_listings_replace_series_course_info_with_class_info(&$course_node, &$class_nodes) {
  $first_class = array_shift($class_nodes);
  node_build_content($first_class,'teaser');
  $course_node->title = $first_class->title;
  $course_node->content['body'][0]['#markup'] = isset($first_class->content['body'])
    ? $first_class->content['body'][0]['#markup']
    : variable_get('sdc_class_missing_description','Details coming soon.');
  $course_node->content['classes'] = array(
    '#markup' => _ilr_sdc_listings_generate_class_link_markup(array($first_class)),
  );
  $group_sidebar = field_group_load_field_group('group_sidebar', 'node', 'sdc_class', 'default');
  $course_node->content['#groups']['group_sidebar'] = $course_node->content['#fieldgroups']['group_sidebar'] = $group_sidebar;
  $course_node->content['#group_children']['classes'] = 'group_sidebar';
}

/**
 * Form function to create class registration form.
 *
 * @param $form
 * @param $form_state
 * @param $class_nodes
 * @param $
 *
 * @return array
 */
function ilr_sdc_listings_class_reg_form($form, &$form_state, $class_nodes) {
  $form['#attributes']['class'][] = 'class-details';
  $form['addClass'] = array(
    '#tree' => TRUE,
  );
  _ilr_sdc_listings_add_radio_markup($form, $class_nodes);
  $markup = '';
  foreach ($class_nodes as $nid => $class_node) {
    $class_node_wrapper = ilr_get_node_wrapper($class_node);
    if ($class_node_wrapper->field_cancelled->value() != 1 && $class_node_wrapper->field_is_full->value() != 1) {
      $class_id = _ilr_sdc_listings_get_class_id($class_node_wrapper);
      $markup .= '<div class="class-detail-toggle class-'.$class_id.'">';
      $markup .= _ilr_sdc_listings_generate_class_button_markup($class_node, TRUE);
      $markup .= '</div>';
    }
  }
  $form['class_detail_toggle'] = array(
    '#type' => 'markup',
    '#markup' => $markup,
  );
  return $form;
}

/**
 * Validation callback for ilr_sdc_listings_class_reg_form.
 *
 * Ensure class selected. Required not working for "radio" type.
 */
function ilr_sdc_listings_class_reg_form_validate($form, &$form_state) {
  if (empty($form_state['values']['addClass'])) {
    form_set_error('addClass', t('You must select a session.'));
  }
}

/**
 * Submit callback for ilr_sdc_listings_class_reg_form.
 *
 * Redirect to registration page.
 */
function ilr_sdc_listings_class_reg_form_submit($form, &$form_state) {
  $registration_path = variable_get('ilr_sdc_listings_reg_url', 'https://registration.ilr.cornell.edu/class/');
  $registration_path .= $form_state['values']['addClass'];
  drupal_goto($registration_path);
}

/**
 * Retrieve the class nid from the url.
 * @return int|null
 */
function _ilr_sdc_listings_get_class_from_url() {
  if (!empty($_GET['class'])) {
    $class_selected = $_GET['class'];
    if (is_numeric($class_selected)) {
      return $class_selected;
    }
  }
  return NULL;
}

/**
 * Get the price of the class or its course.
 *
 * Return the class price if the prices differ.
 * Otherwise, return the course price.
 */
function _ilr_sdc_listings_get_price($class, $course) {
  $course_wrapper = ilr_get_node_wrapper($course);
  $class_wrapper = ilr_get_node_wrapper($class);
  $course_price = $course_wrapper->field_price->value();
  $class_price = $class_wrapper->field_price->value();

  if (!empty($class_price) && $class_price != $course_price) {
    return $class_price;
  }
  return $course_price;
}

/**
 * Determines if any of the classes for course have different titles.
 * @param $class_nodes
 * @param $course_node
 * @return bool
 */
function _ilr_sdc_listings_class_has_override_title($course_node) {
  $course_wrapper = ilr_get_node_wrapper($course_node);
  return drupal_get_title() != $course_wrapper->label();
}

function _ilr_sdc_listings_format_class_date_and_time($class) {
  $wrapper = ilr_get_node_wrapper($class);
  $markup = '<div class="date-time contextual-links-region">';
  $markup .= _ilr_sdc_listings_get_contextual_link_markup($class);
  $datespan_class = ($wrapper->field_cancelled->value() == 1) ? 'date cancelled' : 'date';
  $markup .= '<span class="'.$datespan_class.'">';
  $markup .= _ilr_sdc_listings_get_class_datespan($class);
  $markup .= '</span>';
  $markup .= '<span class="time">';
  if (_ilr_sdc_listings_is_online($class)) {
    $markup .= 'All instruction will be completed between these dates';
  } // Not online, so add the time
  else {
    $markup .= _ilr_sdc_listings_get_class_timespan($class);
  }
  $markup .= '</span>';
  $markup .= '</div>';
  return $markup;
}

function _ilr_sdc_listings_get_class_datespan($class) {
  $markup = '';
  $datetimes = _ilr_sdc_listings_get_datetimes_for_class($class);
  $start_datetime = $datetimes['start'];
  $end_datetime = $datetimes['end'];

  $year = $start_datetime->format('Y');
  if (_ilr_sdc_listings_is_multiday_event($class)) {
    if ($start_datetime->format('M') != $end_datetime->format('M')) {
      $end_day = $end_datetime->format('M j');
    }
    else {
      $end_day = $end_datetime->format('j');
    }
    $markup .=  $start_datetime->format('M j-') . $end_day . ", $year";
  }
  else {
    $markup .= $start_datetime->format('M j') . ", $year";
  }
  return $markup;
}

function _ilr_sdc_listings_get_class_timespan($class) {
  $datetimes = _ilr_sdc_listings_get_datetimes_for_class($class);
  $start_datetime = $datetimes['start'];
  $end_datetime = $datetimes['end'];
  $markup = $start_datetime->format('g:i a') . ' - ';
  $markup .= $end_datetime->format('g:i a');
  return $markup;
}

function _ilr_sdc_listings_is_multiday_event($class) {
  $datetimes = _ilr_sdc_listings_get_datetimes_for_class($class);
  $interval = $datetimes['start']->diff($datetimes['end']);
  return $interval->m > 0 || $interval->d > 0;
}

function _ilr_sdc_listings_is_multiyear_event($class) {
  $datetimes = _ilr_sdc_listings_get_datetimes_for_class($class);
  $interval = $datetimes['start']->diff($datetimes['end']);
  return $interval->y > 0;
}

/**
 * Used to generate the button for courses with classes
 * On teasers, it's the Learn more button, while on course detail pages
 * it's the register button
 */
function _ilr_sdc_listings_generate_class_button_markup($class_node, $include_price=FALSE) {
  $wrapper = ilr_get_node_wrapper($class_node);
  $classes = 'button';
  if ($include_price) {
    $classes .= ' button-register';
    $link_text = 'Register';
    $link = _ilr_sdc_listings_get_class_registration_url($class_node);
  }
  else {
    $classes .= ' button-info';// Note that the js looks for the .button-info class
    $link_text = 'Learn More';
    $nid = (_ilr_sdc_listings_is_series($class_node))
      ? $class_node->nid
      : $wrapper->field_course[0]->value()->nid;
    $link = url('node/'. $nid);
  }
  $markup = '<div class="action"><a role="button" aria-pressed="false" class="'.$classes.'" href="'.$link.'">' . $link_text .' <span class="sr-only"> about '. $class_node->title . '</span></a></div>';
  return $markup;
}

function _ilr_sdc_listings_generate_class_radio_label($class) {
  $markup = '<div class="radio-label contextual-links-region" id="course-' . $class->nid . '">';
  $markup .= _ilr_sdc_listings_get_contextual_link_markup($class);
  if (_ilr_sdc_listings_is_series($class)) {
    $markup .= '<span class="class-title">'.$class->title.'</span>';
  }
  $markup .= _ilr_sdc_listings_generate_class_time_location_markup($class);
  if(_ilr_sdc_listings_has_registration_deadline($class)) {
    $markup .= _ilr_sdc_listings_generate_deadline_markup($class);
  }
  $markup .= '</div>';

  return $markup;
}
/**
 * Generates the markup for landing pages
 * First checks for overflow sessions and removes them if found
 */
function _ilr_sdc_listings_generate_class_link_markup($class_nodes, $view_mode = 'default') {
  $class_nodes = _ilr_sdc_listings_remove_overflow_sessions($class_nodes);
  if (count($class_nodes) > 1) {
    // check for location search and make sure that the cities match if so
    $params = _ilr_sdc_listings_get_field_query_values();
    if (!empty($params['field_address_locality'])) {
      foreach ($class_nodes as $nid => $class_node) {
        $wrapper = ilr_get_node_wrapper($class_node);
        if ($wrapper->field_address->locality->value() !== $params['field_address_locality']) {
          // Move it to the end of the array
          $placeholder = $class_nodes[$nid];
          unset($class_nodes[$nid]);
          $class_nodes[$nid] = $placeholder;
        }
      }
    }
  }
  $class_node = reset($class_nodes);
  $wrapper = ilr_get_node_wrapper($class_node);
  $markup = '<div class="class-details">';
  if (_ilr_sdc_listings_is_ondemand($class_node) || _ilr_sdc_listings_is_online($class_node)) {
    $format = _ilr_sdc_listings_generate_course_format_label($wrapper->field_course[0]->value()->nid);
    $markup .= '<span class="timespan">ONLINE '. $format .'</span>';
    if (_ilr_sdc_listings_is_online($class_node)) {
      // This is the teaser view on the listing page
      $markup .= _ilr_sdc_listings_generate_class_time_location_markup($class_node);
    }
    else {
      $message = (_ilr_sdc_listings_is_ondemand($class_node))
        ? 'Take this self-paced '. strtolower($format).' at your convenience'
        : 'All instruction will be completed between these dates';
      $markup .= '<span class="online-message"> '. $message .'</span>';
    }
  }
  else {
    $markup .= _ilr_sdc_listings_generate_class_timespan_markup($class_node);
    $markup .= _ilr_sdc_listings_generate_class_time_location_markup($class_node);
    if ($view_mode == 'alternate_teaser') {
      $course_price = $wrapper->field_price->value();
      $markup .= '<span class="cost">$'. $course_price .'</span>';
    }
  }
  if ($view_mode != 'alternate_teaser') {
    $markup .= _ilr_sdc_listings_generate_class_button_markup($class_node);
    if (count($class_nodes) > 1) {
      $course_nid = $wrapper->field_course[0]->value()->nid;
      $link = drupal_get_path_alias('node/'.$course_nid);
      $markup .= '<a class="course-details" href="/'.$link. '">See more dates and locations <span class="sr-only">for ' . $class_node->title . '</span></a>';
    }
  }

  $markup .= '</div>';
  return $markup;
}

function _ilr_sdc_listings_get_contextual_link_markup($class) {
  $markup = '';
  if (user_access('access contextual links') && user_access('edit any sdc_class content')) {
    $markup = '<div class="contextual-links-wrapper"><a href="#" class="contextual-links-trigger">Configure</a><ul class="contextual-links">';
    $markup .= '<li class="node-edit first last"><a href="/node/'.$class->nid.'/edit?destination='.current_path().'">Edit</a></li>';
    $markup .= '</ul></div>';
  }
  return $markup;
}

function _ilr_sdc_listings_generate_faculty_markup($class_node, $class_id, $count) {
  $wrapper = ilr_get_node_wrapper($class_node);
  $faculty = $wrapper->field_faculty->value();
  if (empty($faculty)) {
    return '';
  }
  $markup = '<div class="instructors class-detail-toggle class-' . $class_id . '">';
  $markup .= ($count > 1)
    ? '<h3>Instructors for '. _ilr_sdc_listings_get_class_datespan($class_node).' <br><span class="notice multiple-dates">Select another date to see its instructors.</span></h3>'
    : '<h3>Instructors</h3>';
  foreach ($faculty as $key => $instructor) {
    $css_classes = array();
    $instructor_wrapper = ilr_get_node_wrapper($instructor);
    // Update the title and image if there is a referenced profile
    if ($nid = _ilr_sdc_listings_get_referenced_profile_nid($instructor)) {
      $profile_wrapper = ilr_get_node_wrapper($nid);
      if ($profile_image = $profile_wrapper->field_profile_image->value()) {
        $instructor_wrapper->field_thumbnail->set($profile_image);
      }
      $profile_title = $profile_wrapper->field_working_title->value();
      $instructor_wrapper->field_job_title->set($profile_title);
    }
    // Add the silhouette if there is no thumbnail provided
    if (!$instructor_wrapper->field_thumbnail->value() && $fid = variable_get('ilr_missing_profile_image_fid')) {
      if ($silhouette = file_load($fid)) {
        $instructor_wrapper->field_thumbnail->set((array) $silhouette);
      }
    }
    $render_arr = node_view($instructor,'teaser');
    // Remove the read more link
    unset($render_arr['links']['node']['#links']['node-readmore']);
    $markup .= drupal_render($render_arr);
  }
  $markup .= "</div>\n";
  return $markup;
}

function _ilr_sdc_listings_get_referenced_profile_nid($faculty_node) {
  if (!empty($faculty_node->field_people_profile_reference)) {
    $nid = $faculty_node->field_people_profile_reference[LANGUAGE_NONE][0]['target_id'];
    return $nid;
  }
  return FALSE;
}

function _ilr_sdc_listings_generate_location_markup($class) {
  $wrapper = ilr_get_node_wrapper($class);
  $handlers = array('address' => 'address');
  $context = array('mode' => 'render');
  $addressfield_object = $wrapper->field_address->value();
  $address_render_array = addressfield_generate($addressfield_object, $handlers, $context);
  if (_ilr_sdc_listings_is_online($class)) {
    // Fix quirks related to online display
    $address_render_array['#address']['locality'] = "Online";
    $address_render_array['locality_block']['locality']['#suffix'] = ''; // Removes the comma after city
    $address_render_array['#address']['postal_code'] = '';
  }
  $markup = drupal_render($address_render_array);
  return $markup;
}

/**
 * Request info markup changes, depending on whether its the course listing page,
 * course/class node pages, and whether there are classes available
 * All trigger the modal via ilr_sdc_listings.js
 * Note that markup and js are coupled, so only modify it consciously
 */
function _ilr_sdc_listings_generate_request_info_markup($course, $view_mode) {
  if (_ilr_sdc_listings_is_series($course) && count(_ilr_sdc_listings_get_classes_for_course($course))) {
    return '';
  }
  $help_text = 'Schedule customized delivery of this program to your organization';
  $classes_available = _ilr_sdc_listings_get_classes_for_course($course);
  $css_classes = ($view_mode == 'full' && $classes_available) ? 'class-details' : 'group-sidebar class-details';
  $markup = '<div class="'.$css_classes.'">';
  $wrapper = ilr_get_node_wrapper($course);
  if (!$classes_available) {
    $wrapper = ilr_get_node_wrapper($course);
    if (_ilr_sdc_listings_is_online($course)) {
      $format = _ilr_sdc_listings_generate_course_format_label($course);
      $markup .= '<span class="timespan">ONLINE '. $format .'</span>';
    }
    if ($view_mode == 'full') {
      $markup .= '<p class="cost">$'. $wrapper->field_price->value() .'</p>';
    }
    $markup .= '<p class="unscheduled">No currently scheduled dates</p>';
  }
  if ($view_mode == 'teaser') {

    $link = drupal_get_path_alias('node/'.$course->nid);
    $markup .= '<a href="request-info" title="" class="request-info schedule" data-nid="'.$course->nid.'">'.$help_text.'<span class="course-title">'.$course->title.'</span></a>
      <div class="action"><a class="button button-info" href="/'.$link.'">Learn More <span class="sr-only"> about ' .$course->title. '</a></div>';// Note that the js looks for the .button-info class
  } // full node
  else {
    $markup .= '<p class="schedule button-info">'.$help_text.'</p>';
    $markup .= '<a class="link course link--request-info" data-nid="'.$course->nid.'" alt="'.$help_text.'" title="'.$help_text.'">Request';
    $markup .= '<span class="course-title">'.$course->title.'</span></a>';
    $markup .= _ilr_sdc_listings_generate_follow_markup($course);
  }
  $markup .= '</div>';
  return $markup;
}

/**
 *
 */
function _ilr_sdc_listings_generate_follow_markup($course) {
  $help_text = 'Follow this course';
  $markup = '<p class="button-info">Sign-up to be notified when this course is offered.</p>';
  $markup .= '<a class="link link--follow course follow" data-nid="'.$course->nid.'" alt="'.$help_text.'" title="'.$help_text.'">Notify Me ';
  $markup .= '<span class="course-title">'.$course->title.'</span></a>';
  return $markup;
}

function _ilr_sdc_listings_generate_class_timespan_markup($class_node) {
  $wrapper = ilr_get_node_wrapper($class_node);
  $type = _ilr_sdc_listings_generate_course_format_label($wrapper->field_course[0]->value()->nid);
  $datetimes = _ilr_sdc_listings_get_datetimes_for_class($class_node);
  $interval = $datetimes['start']->diff($datetimes['end']);
  if (_ilr_sdc_listings_is_multiyear_event($class_node)) {
    $type = ' class';
    $months = $interval->m;
    if ($months > 10) { // More than a year
      $months = round($months / 12);
      $timespan = $months . '-year';
    } // less than a year
    else {
      $timespan = $months . '-month';
    }
  }
  elseif (_ilr_sdc_listings_is_multiday_event($class_node)) {
    $months = $interval->m;
    $days = $interval->d;
    if ($months > 0) { // More than a month
      $timespan = $months . '-month';
    } // less than a month
    elseif ($days > 10) { // More than a week
      $weeks = round($days / 7);
      $timespan = $weeks . '-week';
    } // less than a week
    else {
      $timespan = $days + 1 . '-day';
    }
  } // Single day event
  else {
    if ($interval->h < 1) { // Less than an hour
      $timespan = $interval->m . '-minute';
    } // more than an hour
    else {
      $hours = $interval->h;
      $timespan = ($hours > 4) ? '1-day' : $hours . '-hour';
    }
  }
  return '<span class="timespan">'. $timespan . ' ' . $type .' </span>';
}

function _ilr_sdc_listings_generate_class_time_location_markup($class_node) {
  $markup = '';
  $wrapper = ilr_get_node_wrapper($class_node);
  $markup .= _ilr_sdc_listings_format_class_date_and_time($class_node);
  if (!empty($city = $wrapper->field_address->value())) {
    $city = $wrapper->field_address->locality->value();
    $state = $wrapper->field_address->administrative_area->value();
    if (!empty($city)) {
      $markup .= (!_ilr_sdc_listings_is_online($class_node))
        ? "<span class='location'>$city, $state</span>"
        : '';
    }
  }
  return $markup;
}

function _ilr_sdc_listings_generate_deadline_markup($class_node) {
  $markup = '';
  $wrapper = ilr_get_node_wrapper($class_node);
  if ($deadline = $wrapper->field_registration_end_date->value()){
    $deadline = date("M j", $deadline);
  }
  if (empty($deadline)) { // This shouldn't happen, @see _ilr_sdc_listings_has_registration_deadline()
    $datetimes = _ilr_sdc_listings_get_datetimes_for_class($class_node);
    $deadline = $datetimes['start'] - 1;
    $deadline = $deadline->format('M j');
  }
  $markup = '<span class="deadline">Register by '.$deadline.'</span>';
  return $markup;
}

/**
 * Generate markup for a course with no scheduled dates
 * for use when explicit markup is required.
 */
function _ilr_sdc_listings_generate_unscheduled_course_markup($course_node, $view_mode) {
  $markup = '<div class="class-details no-dates">';
  $markup .= '<span class="timespan">'. _ilr_sdc_listings_generate_course_format_label($course_node) .'</span>';
  $markup .= '<div class="date-time not-scheduled"><span class="date">no scheduled dates</span><span class="time"></span></div>';
  $markup .= '<span class="location empty"></span>';
  $markup .= '</div>';
  return $markup;
}

function _ilr_sdc_listings_generate_course_format_label($course) {
  $wrapper = ilr_get_node_wrapper($course);
  $format = isset($wrapper->field_course_format_reference[0])
    ? $wrapper->field_course_format_reference[0]->label()
    : 'course';
  $format = preg_replace('/s$/i', '', $format);
  return $format;
}

function _ilr_sdc_listings_get_class_registration_url($class) {
  global $base_url;
  $wrapper = ilr_get_node_wrapper($class);
  $url = variable_get('ilr_sdc_listings_reg_url', 'https://registration.ilr.cornell.edu/class/');
  $class_id = _ilr_sdc_listings_get_class_id($wrapper);
  $url .= $class_id;
  return $url;
}

/**
 * Get class nids for this course.
 * @param $course_node
 * @return array
 *  nids for classes
 */
function _ilr_sdc_listings_get_classes_for_course($course_node, $class_nids = NULL, $remove_cancelled=FALSE) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'sdc_class')
    ->propertyCondition('status', 1)
    ->fieldCondition('field_course', 'target_id', $course_node->nid)
    ->fieldOrderBy('field_class_dates', 'value');
  if ($class_nids) {
    $query->propertyCondition('nid', $class_nids);
  }
  if (_ilr_sdc_listings_date_query_present()) {
    $range = _ilr_sdc_listings_get_date_range();
    $query->fieldCondition('field_class_dates', 'value', $range['start_date'], '>=')
      ->fieldCondition('field_class_dates', 'value2', $range['end_date'], '<=');
    if (!$remove_cancelled) { // Filter out cancelled if it won't be below
      $query->fieldCondition('field_cancelled', 'value', 1, '!=');
    }
  }
  else {
    $today = date('Y-m-d');
    $query->fieldCondition('field_registration_end_date', 'value', $today, '>');
  }
  if ($remove_cancelled) {
    $query->fieldCondition('field_cancelled', 'value', 1, '!=');
  }
  $results = $query->execute();
  if (!empty($results['node'])) {
    return array_keys($results['node']);
  }
  return array();
}

/**
 * Checks the url parameters for the presence of dates values from the filter
 * - caches the result for performance
 * @return boolean
 */
function _ilr_sdc_listings_date_query_present() {
  $present = &drupal_static(__FUNCTION__);
  if (!isset($present)) {
    $start_date_param = (isset($_GET['field_class_dates_value']))
      ? $_GET['field_class_dates_value']['value']['date']
      : '';
    $end_date_param = (isset($_GET['field_class_dates_value2']))
      ? $_GET['field_class_dates_value2']['value']['date']
      : '';
    $present = strlen($start_date_param) || strlen($end_date_param);
  }
  return $present;
}

/**
 * Gets the query string from the url
 * - Adds 1 day to end date to return expected results
 * - caches the result since each class query needs access to the range
 * - ** NOTE ** Leaving the empty value handling logic below, even though this
 *   should no longer happen @see ilr_sdc_listings_filter_validate()
 * @return array
 *  key - start_date or end_date
 *  values - the formatted date objects
 */
function _ilr_sdc_listings_get_date_range() {
  $dates = &drupal_static(__FUNCTION__);
  if (!isset($dates)) {
    $supplied_end_date = (strlen($_GET['field_class_dates_value2']['value']['date']))
      ? date($_GET['field_class_dates_value2']['value']['date'])
      : FALSE;
    if (!empty($_GET['field_class_dates_value']['value']['date'])) {
      $start_date = date($_GET['field_class_dates_value']['value']['date']);
    } // Check if the supplied end date is in the past
    elseif ($supplied_end_date && strtotime($supplied_end_date) < strtotime(date('Y-m-d'))) {
      $start_date = date('Y-m-d',strtotime('-3 months', strtotime($supplied_end_date)));
    } // Use today's date
    else {
      $start_date = date('Y-m-d');
    }
    $end_date = ($supplied_end_date) // Fix the bug that kept <= date from returning the class
      ? date('Y-m-d',strtotime('+1 day', strtotime($supplied_end_date)))
      : date('Y-m-d',strtotime('+1 year', strtotime($start_date))); // One year from start date if empty
    $dates = array(
      'start_date' => $start_date,
      'end_date' => $end_date,
    );
  }
  return $dates;
}
/**
 * Checks whether the registration deadline is different from the start date
 */
function _ilr_sdc_listings_has_registration_deadline($class) {
  $wrapper = ilr_get_node_wrapper($class);
  $deadline = $wrapper->field_registration_end_date->value();
  $datetimes = _ilr_sdc_listings_get_datetimes_for_class($class);
  $date = new DateTime();
  $date->setTimestamp($deadline);
  return $date->format('Y-m-d') !== $datetimes['start']->format('Y-m-d');
}

/**
 * Implements hook_preprocess_hook()
 * Remove node URL from SDC Class and Faculty nodes.
 * Remove title from Class on teaser.
 * Allow italics in course node titles
 */
function ilr_sdc_listings_preprocess_node(&$variables) {
  if ($variables['type'] == 'sdc_faculty') {
    $variables['remove_title_link'] = TRUE;
  }
  if ($variables['type'] == 'sdc_class') {
    if ($variables['view_mode'] != 'teaser') {
      $variables['remove_title_link'] = TRUE;
    }
  }
  if ($variables['type'] == 'sdc_course') {
    $variables['title'] = filter_xss($variables['elements']['#node']->title, array('em'));
    if ($variables['view_mode'] == 'teaser') {
      $variables['classes_array'][] = count(_ilr_sdc_listings_get_classes_for_course($variables['node']))
        ? 'scheduled'
        : 'unscheduled';
      unset($variables['content']['links']['node']['#links']['node-readmore']);
      _ilr_sdc_listings_add_sponsor_data_to_course($variables);
      if (_ilr_sdc_listings_is_series($variables['node'])) {
        $variables['classes_array'][] = 'series';
      }
    }
  }

}

function _ilr_sdc_listings_get_datetimes_for_class($class) {
  $wrapper = ilr_get_node_wrapper($class);
  // Need $class_date_value because DateTime didn't work with
  //  $wrapper->field_class_dates->value()['value']
  $class_date_value = $wrapper->field_class_dates->value();
  $utc = new DateTimeZone('UTC');
  $tz = new DateTimeZone('America/New_York');
  $start = new DateTime($class_date_value['value'], $utc);
  $end = new DateTime($class_date_value['value2'], $utc);
  $start->setTimezone($tz);
  $end->setTimezone($tz);
  return array(
    'start' => $start,
    'end'   => $end,
  );
}
/**
 * Get Views Month Arg from URL.
 *
 * @return string
 *  Month in format YYYY-MM
 */
function _ilr_sdc_listings_get_url_month_arg() {
  if ($url_date = arg(_ilr_sdc_listings_get_path_alias_index())) {
    $value = substr($url_date, 0, 7);
    return $value;
  }
  return NULL;
}

function _ilr_sdc_listings_get_path_alias_index() {
  $parts = explode('/', rtrim(ILR_SDC_PATH_ALIAS, '/'));
  return count($parts) + 1;
}

/**
 * Implements hook_views_pre_render().
 * Adds sort links to course listing page
 * @param $view
 *   The view object about to be processed.
 */
function ilr_sdc_listings_views_pre_render(&$view) {
  if ($view->name == 'sdc_course_listing') {
    $markup = _ilr_sdc_listings_add_sort_elements(array('date','title','program'));
    $view->add_item('default', 'header', 'views', 'area', array('content' => $markup, 'format' => 'full_html'));
  }
}

/**
 * Get query string values that relates to field exposed filters
 *
 * @see drupal_get_query_parameters
 * @return array
 */
function _ilr_sdc_listings_get_field_query_values() {
  $query_parameters = drupal_get_query_parameters();
  foreach (array_keys($query_parameters) as $query_key) {
    if (substr($query_key, 0, 6) !== 'field_') {
      unset($query_parameters[$query_key]);
    }
  }
  return $query_parameters;
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * form_id = ilr_editable_settings_form
 * @see ilr_editable_settings module.
 */
function ilr_sdc_listings_form_ilr_editable_settings_form_alter(&$form, &$form_state, $form_id) {
  $form['sdc_set'] = array(
    '#type' => 'fieldset',
    '#title' => t('SDC Course Listings Messages'),

  );
  $form['sdc_set']['sdc_class_full_full'] = array(
    '#type' => 'textarea',
    '#title' => t('Class is full message on class page'),
    '#default_value' => 'Seats in this session are limited. Please call 866-470-1922 to register.',
  );
  $form['sdc_set']['sdc_class_full_teaser'] = array(
    '#type' => 'textarea',
    '#title' => t('Class is full message on class list'),
    '#default_value' => 'Class is full, but other dates may be available',
  );
  $form['sdc_set']['sdc_class_not_available'] = array(
    '#type' => 'textarea',
    '#title' => t('Class is no longer available'),
    '#default_value' => 'This class date is no longer available.',
  );
  $form['sdc_set']['sdc_class_missing_description'] = array(
    '#type' => 'textarea',
    '#title' => t('Class is missing description'),
    '#default_value' => 'Details coming soon.',
  );
  $form['sdc_set']['sdc_class_selected_not_available'] = array(
    '#type' => 'textarea',
    '#title' => t('Class SELECTED is no longer available'),
    '#default_value' => 'The class you selected is no longer available.',
  );
  $form['sdc_set']['sdc_class_no_sessions'] = array(
    '#type' => 'textarea',
    '#title' => t('Class has no sessions'),
    '#default_value' => 'There are currently no sessions offered.',
  );
  $form['sdc_set']['sdc_class_selected_full'] = array(
    '#type' => 'textarea',
    '#title' => t('Class selected is full'),
    '#default_value' => 'The class date you selected is full.',
  );
  $form['sdc_set']['sdc_class_cancelled'] = array(
    '#type' => 'textarea',
    '#title' => t("Class selected is cancelled"),
    '#default_value' => "We're sorry, but this date has been cancelled.",
  );
}

function ilr_sdc_listings_form_views_exposed_form_alter(&$form, &$form_state) {
  $view = $form_state['view'];
  if ($view->name == 'sdc_course_listing') {
    if (_ilr_sdc_listings_is_filtered_search($view)) {
      $form['#attributes']['class'][] = 'filter-engaged';
    }
    $options = _ilr_sdc_listings_get_active_locations();
    $form['field_address_locality'] = array(
      '#type' => 'select',
      '#options' => $options,
      '#size' => count($options),
      '#validated' => TRUE,
      '#required' => FALSE,
      // '#empty_value' => '',
      '#empty_option' => '- Any -',
    );

    _ilr_sdc_listings_remove_unused_filter_choices($form, $form_state);

    $form['field_online'] = array(
      '#type' => 'checkbox',
      '#title' => t('Online only'),
      '#options' => drupal_map_assoc(array(1)),
      '#validated' => TRUE,
      '#default_value' => 0,
    );

    // Remove the dummy descriptions added via views_hanlder extra_options_form()
    $term_fields = array(
      'field_course_topic_reference_tid',
      'field_course_format_reference_tid',
      'field_course_sponsor_reference_tid',
    );
    foreach ($term_fields as $field) {
      $form[$field]['#description'] = '';
    }
    array_unshift($form['#validate'], 'ilr_sdc_listings_filter_validate');
  }
}

/**
 * Confirms that the user has filled out both a start and end date for date filtering
 */
function ilr_sdc_listings_filter_validate($form, &$form_state) {
  if (!empty($form_state['values']['field_class_dates_value']['value']) || !empty($form_state['values']['field_class_dates_value2']['value'])) {
    if (empty($form_state['values']['field_class_dates_value']['value']) || empty($form_state['values']['field_class_dates_value2']['value'])) {
      form_set_error('email', t('Please choose both a start and end date.'));
    }
  }
}

/**
 * Removes special query groups depending on current filter settings
 * These conditions are set up in the views admin interface,
 * available at admin/structure/views/view/sdc_course_listing/edit/page
 *  - ensures that online queries only return online results
 *  - ensures that city queries only return courses with classes in the future
 */
function ilr_sdc_listings_views_query_alter(&$view, &$query) {
  if($view->name == 'sdc_course_listing') {
    $params = drupal_get_query_parameters();
    if (empty($params['field_online'])) {
      unset($query->where[2]['conditions']);
    }
    if (empty($params['field_address_locality'])) {
      unset($query->where[3]['conditions']);
    }
  }
}

/** Implements hook_views_post_execute
 * Adds a more helpful message if sponsor filter was used and no results found
 */
function ilr_sdc_listings_views_post_execute(&$view) {
  if ($view->name == 'sdc_course_listing' && _ilr_sdc_listings_is_filtered_search($view)) {
    if (isset($view->exposed_input['field_course_sponsor_reference_tid']) && empty($view->result)) {
      $content = '';
      $reference_tids = $view->exposed_input['field_course_sponsor_reference_tid'];
      foreach ($reference_tids as $key => $tid) {
        $sponsor = taxonomy_term_load($tid);
        $sponsor_wrapper = entity_metadata_wrapper('taxonomy_term', $sponsor);
        $message = $sponsor_wrapper->field_error_message->value();
        $content .= $message['value'] . " \n";
      }
      $view->add_item('page', 'empty', 'views', 'area', array('content' => $content, 'format' => 'full_html'));
    }
  }
}

function _ilr_sdc_listings_is_filtered_search($view) {
  return !empty($view->exposed_input) && count($view->exposed_input) > 1;
}

/**
 * Removes topics and formats if they are not currently active
 * Also removes the filter element altogether if it only has 1 active choice
 * Alphabetizes the options
 */
function _ilr_sdc_listings_remove_unused_filter_choices(&$form, $form_state) {
  $check_active = array('field_course_topic_reference_tid', 'field_course_format_reference_tid');
  foreach($form_state['view']->filter as $filter) {
    if (in_array($filter->real_field, $check_active)) {
      $fid = $filter->options['expose']['identifier'];
      $active_terms = _ilr_sdc_listings_get_active_terms($filter->table, $filter->field);
      if (count($active_terms) > 1) {
        // Unset the existing list and add new one with available terms.
        unset($form[$fid]['#options']);
        foreach ($active_terms as $tid => $name) {
          $form[$fid]['#options'][$tid] = $name;
        }
        asort($form[$fid]['#options']);
      } // Remove all traces of the filter
      else {
        unset(
          $form[$fid],
          $form['#info']['filter-' . $fid],
          $form_state['view']->display_handler->options['filters'][$fid],
          $form_state['view']->display_handler->handlers['filter'][$fid],
          $form_state['view']->filter[$fid]);
      }
    }
  }
}

function _ilr_sdc_listings_get_active_terms($table, $field) {
  $query = db_select('taxonomy_term_data', 'terms');
  $query->join($table, 'term_ref', 'term_ref.'.$field.' = terms.tid');
  $term_result = $query
    ->fields('terms', array('tid','name'))
    ->execute()
    ->fetchAllKeyed();
  return array_unique($term_result);
}

function _ilr_sdc_listings_get_active_locations() {
  $locations = array();
  $class_nids = _ilr_sdc_listings_get_upcoming_classes();
  foreach ($class_nids as $key => $nid) {
    $wrapper = ilr_get_node_wrapper($nid);
    if (!empty($wrapper->field_address->value())) {
      $city = $wrapper->field_address->locality->value();
      $state = $wrapper->field_address->administrative_area->value();
      if (!in_array($city, $locations) && strpos($city, 'On-Line') !== 0) {
        $locations[$city] = $city . ', ' . $state;
      }
    }
  }
  return $locations;
}

function _ilr_sdc_listings_get_upcoming_classes() {
  $today = date('Y-m-d');
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'sdc_class')
    ->propertyCondition('status', 1)
    ->fieldCondition('field_registration_end_date', 'value', $today, '>');
  $results = $query->execute();
  if (!empty($results['node'])) {
    return array_keys($results['node']);
  }
}

/**
 * Implements hook_entityform_presave.
 * Sets the registration date for registration forms
 * Sets the job postdate for alumni job postings
 * @see forms.module for form processing
 */
function ilr_sdc_listings_entityform_presave($entityform) {
  if ($entityform->type == 'course_request' || $entityform->type == 'course_follow') {
    $wrapper = entity_metadata_wrapper('entityform', $entityform);
    $course_nid = arg(1);
    $wrapper->field_course[0]->set($course_nid);
  }
}

/**
 * Gets the mlid of a menu link based on the alias
 * See ilr_sdc_listings_update_7001()
 */
function _ilr_sdc_listings_get_mlid_of_path($path) {
  $mlid = array();
  $menu_info = db_select('menu_links' , 'ml')
    ->condition('ml.link_path' , $path)
    ->fields('ml', array('mlid', 'plid'))
    ->execute()
    ->fetchAll();

  if (count($menu_info)) {
    return $menu_info[0]->mlid;
  }
  return NULL;
}

/**
 * Returns the uri of the parent page
 * based on the pathauto alias rules
 * See ilr_sdc_listings_update_7001()
 */
function _ilr_sdc_listings_get_parent_path_alias($path) {
  $parts = explode('/', rtrim($path, '/'));
  $sliced = array_slice($parts, 0, -1);
  return implode("/", $sliced);
}

/**
 * Gets the class detail markup
 */
function _ilr_sdc_listings_get_class_detail_markup($class_node) {
  $markup = '';
  $class_node_wrapper = ilr_get_node_wrapper($class_node);
  $class_id = _ilr_sdc_listings_get_class_id($class_node_wrapper);
  $markup .= '<div class="class-detail-toggle class-'.$class_id.'">';
  $markup .= _ilr_sdc_listings_format_class_date_and_time($class_node);
  $markup .= _ilr_sdc_listings_generate_location_markup($class_node);
  $markup .= '</div>';
  return $markup;
}

/**
 * @todo -test field_is_full
 */
function _ilr_sdc_listings_add_radio_markup(&$form, $classes) {
  $class_radios = array();
  $classes = _ilr_sdc_listings_remove_overflow_sessions($classes);
  foreach ($classes as $nid => $class) {
    $wrapper = ilr_get_node_wrapper($class);
    $class_id = _ilr_sdc_listings_get_class_id($wrapper);
    if ($wrapper->field_is_full->value()) {
      $full_markup = _ilr_sdc_listings_get_course_full_markup($class);
      $form['class_full_with_radio_label'][] = array(
        '#type' => 'markup',
        '#markup' => $full_markup,
      );
    } // Add the radio
    else {
      // See if it's been cancelled
      if ($wrapper->field_cancelled->value() == 1) {
        $form[$class_id] = array(
          '#type' => 'markup',
          '#prefix' => '<div class="class-cancelled">',
          '#suffix' => '<p class="message class-cancelled">Seats for this date are no longer available</p></div>',
          '#markup' => _ilr_sdc_listings_generate_class_radio_label($class),
        );
      } // Handle classes that are not on demand
      elseif (!_ilr_sdc_listings_is_ondemand($class)) {
        $class_radios[] = $class_id;
        $form[$class_id] = array(
          '#type' => 'radio',
          '#return_value' => $class_id,
          '#attributes' => array('name' => 'addClass', 'aria-labelledby' => 'course-' . $nid),
          // Ensure single value in $form_state
          '#parents' => array('addClass'),
        );
        $form['class_radio_label_' . $class_id] = array(
          '#type' => 'markup',
          '#markup' => _ilr_sdc_listings_generate_class_radio_label($class),
        );
      }
    }
  }
  if (!empty($class_radios)) {
    // Set the first as checked
    $first_class_id = reset($class_radios);
    $form[$first_class_id]['#attributes']['checked'] = 'checked';
  }
}

/**
 * Some classes are added as overflow sessions,
 * which means they're in the same location and date/time.
 * This function removes the overflow session(s) if found
 */
function _ilr_sdc_listings_remove_overflow_sessions($classes) {
  if (count($classes) == 1) {
    return $classes;
  }
  $wrappers = $possible_duplicates = $non_duplicates = array();
  foreach ($classes as $nid => $class) {
    $wrappers[$nid] = ilr_get_node_wrapper($class);
    // There should never be duplicate 'online' classes, but we need to check nonetheless
    $city = (!empty($wrappers[$nid]->field_address->value()))
      ? $wrappers[$nid]->field_address->locality->value()
      : 'online';
    $unique_identifier =
      $wrappers[$nid]->field_class_dates->value()['value'] .
      $city;

    // Since array_unique (below) returns the first instance, there are cases
    // where the returned key would be the full course. We avoid that by checking
    // the duplicate and removing it from the possibilities if it's full
    if ($first_dupe = array_search($unique_identifier, $possible_duplicates)) {
      if ($wrappers[$first_dupe]->field_is_full->value()) {
        unset($possible_duplicates[$first_dupe]);
      }
      $possible_duplicates[$nid] = $unique_identifier;
    }
    else {
      $possible_duplicates[$nid] = $unique_identifier;
    }
  }
  $unique_nids = array_unique($possible_duplicates);
  foreach ($unique_nids as $nid => $comparison_string) {
    $non_duplicates[$nid] = $classes[$nid];
  }
  return $non_duplicates;
}

function _ilr_sdc_listings_get_course_full_markup($class) {
  $wrapper = ilr_get_node_wrapper($class);
  $markup = '<div class="class-full">';
  $markup .= _ilr_sdc_listings_generate_class_radio_label($class);
  $markup .= '<p class="message">' . variable_get('sdc_class_full_teaser') . '</p>';
  $markup .= '</div>';
  return $markup;
}

function _ilr_sdc_listings_set_default_body(&$node) {
  if (empty($node->body)) {
    $message = variable_get('sdc_class_missing_description', 'Details coming soon.');
    $node->body[LANGUAGE_NONE][0] = array(
      'value' => "<p>$message</p>",
      'summary' => '',
      'format' => 'full_html',
    );
    $node->content['body'] = array(
      0 => array(
        '#markup' => "<p>$message</p>",
      ),
      '#weight' => 10,
    );
  }
}

/**
 * Adds a canonical href for wrapped nodes
 */
function _ilr_sdc_listings_add_canonical_metatag($node, $view_mode) {
  if ($view_mode == 'full') {
    drupal_add_html_head_link(array(
      'rel' => 'canonical',
      'href' => url('node/'.$node->nid, array('absolute' => TRUE)),
    ));
  }
}

/**
 * Adds the prefix to the title if it hasn't been added yet
 * Skips course titles when they are referenced nodes (for series class pages)
 */
function _ilr_sdc_listings_add_prefix_to_title($node, $type, $view_mode) {
  if ($view_mode == 'reference_field') {
    return FALSE;
  }
  // Update the page title for course nodes
  if ($view_mode == 'full') {
    $title = _ilr_sdc_listings_get_prefixed_node_title($node, $type);
    drupal_set_title($title);
  }
}

function _ilr_sdc_listings_get_prefixed_node_title($node,$type) {
  $wrapper = ilr_get_node_wrapper($node);
  $prefix = ($type == 'sdc_class')
    ? $wrapper->field_course[0]->field_catalog_prefix->value()
    : $wrapper->field_catalog_prefix->value();

  if (strpos($node->title,$prefix) === FALSE) {
    $title = $node->title . ' (' . $prefix . ')';
    return $title;
  }
  return $node->title;
}

/**
 * Updates the rendered course entity on classes
 * when classes are part of a series
 */
function _ilr_sdc_listings_update_reference(&$course) {
  if (_ilr_sdc_listings_is_series($course)) {
    $title = 'Part of: <em>'.$course->title.'</em>';
    unset($course->content['body']);
  }
  else {
    $title = '';
  }
  $course->title = $title;
}

/**
 * Looks for all cancelled classes in the past and unpublishes them if found
 * If we delete them, the class gets added again during the next import
 * @see ilr_sdc_listings_cron()
 */
function _ilr_sdc_listings_remove_cancelled_classes() {
  $today = date('Y-m-d');
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'sdc_class')
    ->fieldCondition('field_class_dates', 'value', $today, '<')
    ->fieldCondition('field_cancelled', 'value', 1, '=');

  $results = $query->execute();
  if (!empty($results['node'])) {
    $nids = array_keys($results['node']);
    foreach ($nids as $key => $nid) {
      $wrapper = ilr_get_node_wrapper($nid);
      $wrapper->status = 0;
      $wrapper->save();
    }
  }
}

/**
 * Specifies which of the course and class fields are protected from
 * being edited in Drupal
 */
function _ilr_sdc_listings_get_protected_fields() {
  global $user;
  if ($user->uid == 1) {
    return array(
      'sdc_class_node_form'   => array(),
      'sdc_course_node_form'  => array(),
      'sdc_faculty_node_form' => array(),
    );
  }
  return array(
    'sdc_class_node_form' => array(
      'title',
      'field_address',
      'field_class_dates',
      'field_class_id',
      'field_course',
      'field_faculty',
      'field_is_full',
      'field_on_demand',
      'field_online_class',
      'field_building',
      'field_price'
    ),
    'sdc_course_node_form' => array(
      'title',
      'field_catalog_prefix',
      'field_credit_hours',
      'field_on_demand',
      'field_sdc_department',
      'field_price',
      'field_price_note',
    ),
    'sdc_faculty_node_form' => array(
      'title',
    ),
  );
}

/**
 * Get the salesforce id, or return the legacy class id if it isn't mapped
 *
 * @todo
 *   - consider removing once legacy class ids are no longer relevant
 */
function _ilr_sdc_listings_get_class_id($wrapper) {
  $class_id = ($wrapper->field_sf_record_id->value())
    ? $wrapper->field_sf_record_id->value()
    : $wrapper->field_class_id->value();
  return $class_id;
}

/**
 * Implements hook_node_presave().
 * Set the registration end date to the class start date if not present.
 */
function ilr_sdc_listings_node_presave($node) {
  if ($node->type == 'sdc_class') {
    // empty during insert, but other saves can include empty 'und' key
    if (empty($node->field_registration_end_date) || empty($node->field_registration_end_date[LANGUAGE_NONE])) {
      $start_date = $node->field_class_dates[LANGUAGE_NONE][0]['value'];
      $node->field_registration_end_date[LANGUAGE_NONE][0] = [
        'value' => $start_date,
        'timezone' => 'UTC',
        'timezone_db' => 'UTC',
      ];
    }
  }
}

function ilr_sdc_listings_get_program($node) {
  if ($node->type == 'sdc_class') {
    $class_wrapper = entity_metadata_wrapper('node', $node);
    $course_nid = $class_wrapper->field_course[0]->getIdentifier();
    $wrapper = entity_metadata_wrapper('node', $course_nid);
  }
  else {
    $wrapper = entity_metadata_wrapper('node', $node);
  }
  return $wrapper->field_program_reference->value()->name;
}

function ilr_sdc_listings_get_prefix($node) {
  $wrapper = ilr_get_node_wrapper($node);
  $prefix = ($node->type == 'sdc_class')
    ? $wrapper->field_course[0]->field_catalog_prefix->value()
    : $wrapper->field_catalog_prefix->value();
  return $prefix;
}
