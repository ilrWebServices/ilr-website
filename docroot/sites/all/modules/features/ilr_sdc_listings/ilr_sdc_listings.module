<?php
/**
 * @file
 * Code for the ilr_sdc_listings feature.
 *
 * @todo How should the placement for calendar nav view block should be handled.
 */

include_once 'ilr_sdc_listings.features.inc';
/**
 * Connect Faculty to classes from JSON file.
 *
 * This is triggered after all importers for this modules
 * @see ilr_sdc_listings_feeds_after_import().
 */
function _ilr_sdc_listings_set_faculty_for_classes() {
  $new_assignments = _ilr_sdc_listings_new_assignments();
  if ($new_assignments) {
    $current_assignments = _ilr_get_entityreference_relations('field_faculty', 'sdc_class');
    _ilr_sdc_listings_save_new_assignments($new_assignments, $current_assignments);
    _ilr_sdc_listings_save_videos_no_playlists($current_assignments, $new_assignments);
  }
}

/**
 * Returns new class faculty assignments.
 * @return array
 *  An associative array whose keys are the Class nids and values are array of faculty.
 */
function _ilr_sdc_listings_new_assignments() {
  $faculty_class_relationships = _ilr_sdc_listings_retrieve_faculty_class_relationships();
  $new_class_assignments = array();
  $unknown_classes = array();
  $unknown_faculty = array();
  foreach ($faculty_class_relationships as $faculty_class_relationship) {

    $class_nid = _ilr_get_feeds_item_entity_id($faculty_class_relationship['CLASS_OID'], 'sdc_class_importer');
    $faculty_nid = _ilr_get_feeds_item_entity_id($faculty_class_relationship['FACULTY_OID'], 'sdc_faculty_importer');
    // Keep of list of classes and faculty that aren't nodes.
    if (!$class_nid) {
      $unknown_classes[] = $faculty_class_relationship['CLASS_OID'];
    }
    if (!$faculty_nid) {
      $unknown_faculty[] = $faculty_class_relationship['FACULTY_OID'];
    }
    if ($class_nid && $faculty_nid) {
      // Both the class and faculty were found.
      // Check that faculty is not already set(duplicate entries in assignment json).
      if (empty($new_class_assignments[$class_nid]) || !in_array($faculty_nid, $new_class_assignments[$class_nid])) {
        $new_class_assignments[$class_nid][] = $faculty_nid;
      }
    }
  }
  if ($unknown_classes) {
    watchdog('ilr_sdc_listings', 'Unknown classes were found during class assignment. @class_ids', array('@class_ids' => implode(',', $unknown_classes)), WATCHDOG_WARNING);
  }
  if ($unknown_faculty) {
    watchdog('ilr_sdc_listings', 'Unknown faculty were found during class assignment. @faculty_ids', array('@faculty_ids' => implode(',', $unknown_faculty)), WATCHDOG_WARNING);
  }
  return $new_class_assignments;
}

/**
 * Retrieve Class/Faculty relationships.
 * @return array();
 *  Indexed array where values are arrays with values:
 *  - class_id
 *  - faculty_id
 */
function _ilr_sdc_listings_retrieve_faculty_class_relationships() {
  $assignments_url = variable_get('ilr_sdc_listings_faculty_class_assignments_url', FALSE);
  if (!$assignments_url) {
    watchdog('ilr_sdc_listings', 'Error ilr_sdc_listings_faculty_class_assignments_url variable not set.', WATCHDOG_ERROR);
    return array();
  }
  $response = drupal_http_request($assignments_url);
  if ($response->error) {
    watchdog('ilr_sdc_listings', 'Error retrieving feed: @msg', array('@msg' => $response->error), WATCHDOG_ERROR);
    return array();
  }
  $relationships = drupal_json_decode($response->data);
  return $relationships;
}

/**
 * Save all class/faculty assignments where assignments that are different from current assignments.
 * @param $new_assignments
 *  An associative array whose keys are the Class nids and values are array of faculty nids.
 * @param $current_assignments
 *  An associative array whose keys are the Class nids and values are array of faculty nids.
 */
function _ilr_sdc_listings_save_new_assignments($new_assignments, $current_assignments) {
  // Loop through new assignments and update only need ones. Saves calls to node_save.
  foreach ($new_assignments as $referencer_nid => $referenced_nids) {
    // If the video is not currently assigned to a playlists needs to be assigned
    $needs_update = !isset($current_assignments[$referencer_nid]);
    if (!$needs_update) {
      sort($referenced_nids);
      sort($current_assignments[$referencer_nid]);
      // Check that array of nids are equal after sort.
      $needs_update = $referenced_nids != $current_assignments[$referencer_nid];
    }
    if ($needs_update) {
      // Update assignment
      $node_wrapper = entity_metadata_wrapper('node', $referencer_nid);
      //$referenced_nids = array_map('intval',$referenced_nids);
      $node_wrapper->field_faculty->set($referenced_nids);
      $node_wrapper->save();
    }
  }
}

/**
 * Remove faculty from classes that have set values
 * @param $current_assignments
 * @param $new_assignments
 */
function _ilr_sdc_listings_save_videos_no_playlists($current_assignments, $new_assignments) {
  // Remove any video that aren't in assignments but were in current
  $unassigned_nids = array_keys(array_diff_key($current_assignments, $new_assignments));
  if ($unassigned_nids) {
    foreach ($unassigned_nids as $nid) {
      $node_wrapper = entity_metadata_wrapper('node', $nid);
      $node_wrapper->field_faculty->set();
      $node_wrapper->save();
    }
  }
}

/**
 * Implements hook_playlist_feeds_after_import().
 *
 * Automatically run other imports after course import is run.
 * Run faculty/class assigner.
 */
function ilr_sdc_listings_feeds_after_import(FeedsSource $source) {
  $chained_importers = _ilr_sdc_listings_get_importer_ids();
  $importer_index = array_search($source->importer->id, $chained_importers);
  if ($importer_index !== FALSE) {
    if ($importer_index < count($chained_importers) - 1) {
      // Run the next importer automatically.
      $source = feeds_source($chained_importers[$importer_index + 1]);
      if ($source) {
        $source->startImport();
      }
    }
    else {
      // Last importer assign faculty to classes
      _ilr_sdc_listings_set_faculty_for_classes();
    }
  }
}

/**
 * Implements hook_feeds_after_parse().
 *
 * Loop through all results from feed and prepare for import.
 */
function ilr_sdc_listings_feeds_after_parse(FeedsSource $source, FeedsParserResult $result) {
  $importer_ids = _ilr_sdc_listings_get_importer_ids();

  if (in_array($source->importer->id, $importer_ids)) {
    foreach ($result->items as &$item) {
      _ilr_sdc_listings_prepare_source_item($item, $source);
    }
  }
}

/**
 * Prepare source item for import.
 * @param array $item
 *  Feeds source item
 * @param $source
 *  Importer source
 */
function _ilr_sdc_listings_prepare_source_item(array &$item, FeedsSource $source) {
  $importer_id = $source->importer->id;

  $body_source = _ilr_get_feed_source_for_target('body', $source->importer);
  foreach ($item as $key => &$item_prop) {
    _ilr_sdc_listings_source_cleanup_item_property($item_prop);
    if ($key == $body_source) {
      _ilr_sdc_listings_replace_course_links($item_prop);
    }
  }
  if ($importer_id == 'sdc_class_importer') {
    _ilr_sdc_listings_prepare_class_source_item($item, $source);
  }
}

/**
 * @param array $item
 * @param FeedsSource $source
 */
function _ilr_sdc_listings_prepare_class_source_item(array &$item, FeedsSource $source) {
  $country_source = _ilr_get_feed_source_for_target('field_address:country', $source->importer);
  if ($country_source) {
    // Hardcode US as country because addressfield needs this.
    $item[$country_source] = 'US';
  }
  _ilr_sdc_listings_feeds_set_date_string($item, $source->importer, 'field_class_dates:start', 'Temporary target 1', 'Temporary target 2');
  _ilr_sdc_listings_feeds_set_date_string($item, $source->importer, 'field_class_dates:end', 'Temporary target 3', 'Temporary target 4');

}

/**
 * Sets the creates a timestamp from the incoming date and time strings
 *
 * @param array $feed_item
 * @param FeedsImporter $importer
 * @param $date_time_target
 *  Feeds mapping target for date field
 * @param $date_target
 *  Feeds mapping target for date.
 * @param $time_target
 *  Feeds mapping target for time
 */
function _ilr_sdc_listings_feeds_set_date_string(array &$feed_item, FeedsImporter $importer, $date_time_target, $date_target, $time_target) {
  $date = $feed_item[_ilr_get_feed_source_for_target($date_target, $importer)];
  $time = $feed_item[_ilr_get_feed_source_for_target($time_target, $importer)];
  $time = str_pad($time, 5, '0', STR_PAD_LEFT);
  $time = substr($time, 0, 2) . ':' . substr($time, -3, 2) . strtoupper(substr($time, -1, 1)) . 'M';
  $start_date_source = _ilr_get_feed_source_for_target($date_time_target, $importer);
  // Have to use Unix timestamp instead of date time string to handle timezone correctly. See - https://www.drupal.org/node/722740
  $feed_item[$start_date_source] = strtotime("$date $time");
}

/**
 * Replace direct links to courses with links to redirect to node page.
 * @param $description
 */
function _ilr_sdc_listings_replace_course_links(&$description) {
  $link_pattern = "/http:\/\/www.ilr.cornell.edu\/(.{1,10})\/catalog\/(.{1,10})\.html/i";
  $replace = '/catalog-course/$2';
  $description = preg_replace($link_pattern, $replace, $description);
}

/**
 * Cleanup source property from JSON import because they are double escaped.
 * @param $item_prop
 */
function _ilr_sdc_listings_source_cleanup_item_property(&$item_prop) {
  if (is_numeric($item_prop)) {
    return;
  }
  $item_prop = trim($item_prop, "\"");
  $replace_strings = array(
    "\\n" => "\n",
    "\\t" => "\t",
    "\\" => "",
  );
  foreach ($replace_strings as $orig => $new) {
    $item_prop = str_replace($orig, $new, $item_prop);
  }
}

/**
 * Get feeds importer ids in the order they should be processed.
 * @return array
 */
function _ilr_sdc_listings_get_importer_ids() {
  return array_keys(_ilr_sdc_listings_get_importer_files());
}

/**
 * Get importer files.
 * @return array
 *  Key are importer ids. Values are names of import files.
 */
function _ilr_sdc_listings_get_importer_files() {
  $importer_files = array(
    'sdc_course_importer' => 'ncourse',
    'sdc_class_importer' => 'nclass',
    'sdc_faculty_importer' => 'facultyFromSDC',
  );
  return $importer_files;
}

/**
 * Implements hook_menu().
 */
function ilr_sdc_listings_menu() {
  $items = array();

  $items['catalog-course/%'] = array(
    'type' => MENU_CALLBACK,
    'access arguments' => array('access content'),
    'page callback' => '_ilr_sdc_listings_catalog_redirect',
    'page arguments' => array(1),
  );
  return $items;
}

/**
 * Redirect to the node page the matches the catalog number.
 * @param $catalog_num
 * @return int
 */
function _ilr_sdc_listings_catalog_redirect($catalog_num) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'sdc_course')
    ->fieldCondition('field_catalog_prefix', 'value', $catalog_num);
  $results = $query->execute();
  if (!empty($results['node'])) {
    $nid = array_pop(array_keys($results['node']));
    drupal_goto("node/$nid");
    return;
  }
  return MENU_NOT_FOUND;
}

/**
 * Implements hook_node_view().
 */
function ilr_sdc_listings_node_view($node, $view_mode, $langcode) {

  switch ($node->type) {
    case 'sdc_course':
      _ilr_sdc_listings_course_add_classes($node, $view_mode);
  }
}

/**
 * Add class listing form to node course view.
 * @param $course_node
 * @param $view_mode
 */
function _ilr_sdc_listings_course_add_classes($course_node, $view_mode) {

  if ($view_mode == 'full') {
    $class_nids = _ilr_sdc_listings_get_classes_for_course($course_node);
    $class_selected = _ilr_sdc_listings_get_class_from_url();
    if ($class_selected && !in_array($class_selected, $class_nids)) {
      drupal_set_message(t('The class you selected is no longer availiable.'));
    }
    if ($class_nids) {
      $class_nodes = node_load_multiple($class_nids);
      $has_override_price = _ilr_sdc_listings_class_has_override_price($class_nodes, $course_node);
      $form = drupal_get_form('ilr_sdc_listings_class_reg_form', $class_nodes, $has_override_price);
      $course_node->content['classes'] = $form;
      if ($has_override_price) {
        // If there is any class that has a different price we don't show price on course level
        unset($course_node->content['field_price']);
      }
    }
    else {
      $course_node->content['classes'] = array(
        '#type' => 'markup',
        // @todo Decide on exact wording for no classes. Should this be configurable?
        '#markup' => t('There are currently no sessions offered.'),
      );
    }
    $course_node->content['classes']['#weight'] = 2;
  }
}

/**
 * Form function to create class registration form.
 * @param $form
 * @param $form_state
 * @param $class_nodes
 * @param $has_override_price
 * @return array
 */
function ilr_sdc_listings_class_reg_form($form, &$form_state, $class_nodes, $has_override_price) {
  $render_arrays = node_view_multiple($class_nodes, 'teaser');
  foreach (element_children($render_arrays['nodes']) as $nid) {
    // Remove title because it is the same as the course
    $render_array = & $render_arrays['nodes'][$nid];
    $render_array['#node']->title = '';
    unset($render_array['links']);
    if (!$has_override_price) {
      unset($render_array['field_price']);
    }
    $options[$nid] = drupal_render($render_arrays['nodes'][$nid]);
  }

  $form['class'] = array(
    '#title' => t('Select the session you\'d like to attend'),
    '#type' => 'radios',
    '#options' => $options,
    '#required' => TRUE,
    '#default_value' => _ilr_sdc_listings_get_class_from_url(),
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Register'),
  );
  return $form;
}

/**
 * Retrieve the class nid from the url.
 * @return int|null
 */
function _ilr_sdc_listings_get_class_from_url() {
  if (!empty($_GET['class'])) {
    $class_selected = $_GET['class'];
    if (is_numeric($class_selected)) {
      return $class_selected;
    }
  }
  return NULL;
}

/**
 * Determines if any of the classes for course have different prices.
 * @param $class_nodes
 * @param $course_node
 * @return bool
 */
function _ilr_sdc_listings_class_has_override_price($class_nodes, $course_node) {
  $course_wrapper = entity_metadata_wrapper('node', $course_node);
  $course_price = $course_wrapper->field_price->value();
  foreach ($class_nodes as $class_node) {
    $class_wrapper = entity_metadata_wrapper('node', $class_node);
    if ($course_price != $class_wrapper->field_price->value()) {
      return TRUE;
    }
  }
  return FALSE;
}

/**
 * Get class nids for this course.
 * @param $course_node
 * @return array
 *  nids for classes
 */
function _ilr_sdc_listings_get_classes_for_course($course_node) {
  $today = date('Y-m-d');
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'sdc_class')
    ->propertyCondition('status', 1)
    ->fieldCondition('field_course', 'target_id', $course_node->nid)
    ->fieldCondition('field_registration_end_date', 'value', $today, '>=');
  $results = $query->execute();
  if (!empty($results['node'])) {
    return array_keys($results['node']);
  }
  return array();
}

/**
 * Implements hook_preprocess_hook()
 *
 * Remove node URL from SDC Faculty nodes.
 */
function ilr_sdc_listings_preprocess_node(&$variables) {
  if ($variables['type'] == 'sdc_faculty' && $variables['view_mode'] == 'teaser') {
    $variables['remove_title_link'] = TRUE;
  }
}

/**
 * Alter the default value for a date argument.
 *
 * @param object $argument
 *   The argument object.
 * @param string $value
 *   The default value created by the argument handler.
 */
function ilr_sdc_listings_date_default_argument_alter(&$argument, &$value) {
  $view = $argument->view;
  if ($view->name == 'sdc_class_calendar' && $view->current_display == 'block_nav') {
    if ($url_month = _ilr_sdc_listings_get_url_month_arg()) {
      $value = $url_month;
    }
  }
}

/**
 * @return string
 */
function _ilr_sdc_listings_get_url_month_arg() {
  if ($url_date = arg(1)) {
    $value = substr($url_date, 0, 7);
    return $value;
  }
  return NULL;
}

/**
 * Implements hook_form_alter().
 */
function ilr_sdc_listings_form_views_exposed_form_alter(&$form, &$form_state, $form_id) {
  $view = $form_state['view'];
  if ($view->name == 'sdc_class_calendar' && isset($form['field_class_dates_value'])) {
    array_unshift($form['#submit'], '_ilr_sdc_listings_handle_date_select');
  }
}
function _ilr_sdc_listings_handle_date_select($form, &$form_state) {
  dpm($form_state['values'],'fs');
}
/**
 * This hook is called right before the render process. The query has been
 * executed, and the pre_render() phase has already happened for handlers, so
 * all data should be available.
 *
 * Adding output to the view can be accomplished by placing text on
 * $view->attachment_before and $view->attachment_after. Altering the content
 * can be achieved by editing the items of $view->result.
 *
 * This hook can be utilized by themes.
 * @param $view
 *   The view object about to be processed.
 */
function ilr_sdc_listings_views_pre_render(&$view) {
  if ($view->name == 'sdc_class_calendar' && $view->current_display == 'block_nav') {
    $view->attachment_before = drupal_render(drupal_get_form('_ilr_listings_sdc_select_month_form'));
  }
}
function _ilr_listings_sdc_select_month_form($form, &$form_state) {
  if ($url_month = _ilr_sdc_listings_get_url_month_arg()) {
    $start_month = $url_month;
  }
  else {
    $start_month = date('Y-m');
  }
  $base_path = '/' . arg(0) . '/';
  $month_options = _ilr_sdc_listings_get_month_options($start_month, 7, $base_path);

  $form['ilr_sdc_month_redirect'] = array(
    '#type' => 'select',
    '#options' => $month_options,
    '#default_value' => $base_path .$start_month,
  );
  $form['#attached']['js'] = array(
    drupal_get_path('module', 'ilr_sdc_listings') . '/js/ilr_sdc_listings.js',
  );
  return $form;
}

/**
 * @param $start_month
 * @param $month_options
 * @return mixed
 */
function _ilr_sdc_listings_get_month_options($start_month, $month_count, $key_prefix = '') {
  $month_options = array();
  $half_count = round($month_count/2);
  $month = date('Y-m', strtotime("-3 months", strtotime($start_month)));
  $i = 0;
  while ($i++ < $month_count) {
    $month_options[$key_prefix . $month] = date('M Y', strtotime($month));
    $month = date('Y-m', strtotime("+1 months", strtotime($month)));
  }
  return $month_options;
}